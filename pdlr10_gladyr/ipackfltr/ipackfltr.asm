; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr10_gladyr\ipackfltr\ipackfltr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deviceName_buffer
PUBLIC	_deviceName
PUBLIC	_symbolicLinkName_buffer
PUBLIC	_symbolicLinkName
PUBLIC	_IpFltrDevName_buffer
PUBLIC	_IpFltrDevName
PUBLIC	_gPacketsListHead
PUBLIC	_gListSpinLock
_BSS	SEGMENT
_gPacketsListHead DQ 01H DUP (?)
_gListSpinLock DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_deviceName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, '\', 00H, 'i', 00H, 'p', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, 'f', 00H, 'l', 00H, 't', 00H, 'r', 00H, 00H, 00H
_deviceName DW	022H
	DW	024H
	DD	FLAT:_deviceName_buffer
_symbolicLinkName_buffer DB '\', 00H, '?', 00H, '?', 00H, '\', 00H, 'i', 00H
	DB	'p', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'f', 00H, 'l', 00H, 't'
	DB	00H, 'r', 00H, 00H, 00H
_symbolicLinkName DW 01aH
	DW	01cH
	DD	FLAT:_symbolicLinkName_buffer
_IpFltrDevName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'I', 00H, 'P', 00H, 'F', 00H, 'I'
	DB	00H, 'L', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'D', 00H, 'R', 00H
	DB	'I', 00H, 'V', 00H, 'E', 00H, 'R', 00H, 00H, 00H
	ORG $+2
_IpFltrDevName DW 02cH
	DW	02eH
	DD	FLAT:_IpFltrDevName_buffer
CONST	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_DeviceControlDispatchRoutine@8
PUBLIC	_ReadDispatchRoutine@8
PUBLIC	_CloseDispatchRoutine@8
PUBLIC	_InitializeListHead@4
PUBLIC	_KeInitializeSpinLock@4
PUBLIC	??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0EB@DDIBKOML@DriverEntry?3IoGetDeviceObjectPoi@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	_DriverEntry@8
EXTRN	__imp__KeInitializeEvent@12:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoGetDeviceObjectPointer@16:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
;	COMDAT ??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@
; File c:\radasm\wdk\projects\driver_projects\pdlr10_gladyr\ipackfltr\ipackfltr.c
INIT$s	SEGMENT
??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@ DB 'DriverE'
	DB	'ntry:IoCreateSymbolicLink fails with status = 0x%08X', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0EB@DDIBKOML@DriverEntry?3IoGetDeviceObjectPoi@PBOPGDP@
INIT$s	SEGMENT
??_C@_0EB@DDIBKOML@DriverEntry?3IoGetDeviceObjectPoi@PBOPGDP@ DB 'DriverE'
	DB	'ntry:IoGetDeviceObjectPointer fails with status = 0x%08X', 0aH
	DB	00H						;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@
INIT$s	SEGMENT
??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@ DB 'Driver'
	DB	'Entry:IoCreateDevice fails with status = 0x%08X for device wi'
	DB	'th name %wZ', 0aH, 00H			;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_status$ = -12						; size = 4
_DeviceObject$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 9    : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 10   : 	NTSTATUS			status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 11   : 	PDEVICE_OBJECT		DeviceObject	= NULL;

	mov	DWORD PTR _DeviceObject$[ebp], 0

; 12   : 	PDEVICE_EXTENSION	devExt		= NULL;

	mov	DWORD PTR _devExt$[ebp], 0

; 13   : 
; 14   : 	UNREFERENCED_PARAMETER(RegistryPath);
; 15   : 
; 16   : 	__debugbreak();

	int	3

; 17   : 	status = IoCreateDevice(	DriverObject,
; 18   : 							sizeof(DEVICE_EXTENSION),
; 19   : 							(PUNICODE_STRING)&deviceName,
; 20   : 							DEV_TYPE, FILE_DEVICE_SECURE_OPEN,
; 21   : 							FALSE, &DeviceObject	);                        

	lea	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	push	34					; 00000022H
	push	OFFSET _deviceName
	push	36					; 00000024H
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 22   : 	
; 23   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@DriverEntr

; 24   : 	{
; 25   : 		KdPrint((__FUNCTION__":IoCreateDevice fails with status = 0x%08X for device with name %wZ\n", 
; 26   : 					status, (PUNICODE_STRING)&deviceName) );

	push	OFFSET _deviceName
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 27   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN3@DriverEntr:

; 28   : 	}
; 29   : 	
; 30   : 	devExt = DeviceObject->DeviceExtension;

	mov	eax, DWORD PTR _DeviceObject$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _devExt$[ebp], ecx

; 31   : 	status = IoGetDeviceObjectPointer(
; 32   : 					(PUNICODE_STRING)&IpFltrDevName,   
; 33   : 					FILE_ALL_ACCESS, 
; 34   : 					&devExt->IpFltrFileObj, 
; 35   : 					&devExt->IpFltrDevObj);   

	mov	edx, DWORD PTR _devExt$[ebp]
	push	edx
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 4
	push	eax
	push	2032127					; 001f01ffH
	push	OFFSET _IpFltrDevName
	call	DWORD PTR __imp__IoGetDeviceObjectPointer@16
	mov	DWORD PTR _status$[ebp], eax

; 36   :     			
; 37   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@DriverEntr

; 38   : 	{
; 39   : 		KdPrint((__FUNCTION__":IoGetDeviceObjectPointer fails with status = 0x%08X\n",status ));

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EB@DDIBKOML@DriverEntry?3IoGetDeviceObjectPoi@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 40   : 		IoDeleteDevice(DeviceObject);

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 41   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN2@DriverEntr:

; 42   : 	}
; 43   : 
; 44   : 	status = IoCreateSymbolicLink(	(PUNICODE_STRING)&symbolicLinkName, 
; 45   : 								(PUNICODE_STRING)&deviceName	);

	push	OFFSET _deviceName
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 46   : 		
; 47   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@DriverEntr

; 48   : 	{
; 49   : 		KdPrint((__FUNCTION__":IoCreateSymbolicLink fails with status = 0x%08X\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 50   : 		ObDereferenceObject(devExt->IpFltrFileObj);

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	DWORD PTR __imp_@ObfDereferenceObject@4

; 51   : 		IoDeleteDevice(DeviceObject);

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 52   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN4@DriverEntr
$LN1@DriverEntr:

; 53   : 	}
; 54   : 	KeInitializeEvent( &devExt->IpFltrEvent, NotificationEvent,  FALSE);

	push	0
	push	0
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 8
	push	eax
	call	DWORD PTR __imp__KeInitializeEvent@12

; 55   : 	KeInitializeSpinLock( &gListSpinLock );

	push	OFFSET _gListSpinLock
	call	_KeInitializeSpinLock@4

; 56   : 	InitializeListHead( &gPacketsListHead );

	push	OFFSET _gPacketsListHead
	call	_InitializeListHead@4

; 57   : 	devExt->IpFltrStatus.Status = STATUS_NOT_IMPLEMENTED;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+24], -1073741822		; c0000002H

; 58   : 	
; 59   : 	DeviceObject->Flags |= DO_BUFFERED_IO;//DO_DIRECT_IO;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+28]
	or	eax, 4
	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 60   : 			
; 61   : 	DriverObject->MajorFunction[IRP_MJ_CREATE]			= 
; 62   : 	DriverObject->MajorFunction[IRP_MJ_CLOSE]				= CloseDispatchRoutine;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+64], OFFSET _CloseDispatchRoutine@8
	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+56], edx

; 63   : 	DriverObject->MajorFunction[IRP_MJ_READ]				= ReadDispatchRoutine;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+68], OFFSET _ReadDispatchRoutine@8

; 64   : 	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]	= DeviceControlDispatchRoutine;

	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [ecx+112], OFFSET _DeviceControlDispatchRoutine@8

; 65   : 	DriverObject->DriverUnload								= DriverUnload;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+52], OFFSET _DriverUnload@4

; 66   : 	
; 67   : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN4@DriverEntr:

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
; Function compile flags: /Odtp
; File c:\winddk\inc\ddk\wdm.h
INIT	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC				; COMDAT

; 7550 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	ecx, DWORD PTR _ListHead$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _ListHead$[ebp]
	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	DWORD PTR [edx], eax

; 7552 : }

	pop	ebp
	ret	4
_InitializeListHead@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

	npad	2
	push	ebp
	mov	ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

	mov	eax, DWORD PTR _SpinLock$[ebp]
	mov	DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

	pop	ebp
	ret	4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_CreateDispatchRoutine@8
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__RtlAssert@16:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
;	COMDAT ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
; File c:\radasm\wdk\projects\driver_projects\pdlr10_gladyr\ipackfltr\ipackfltr.c
PAGE$s	SEGMENT
??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@ DB 'Irp', 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_01GBGANLPD@0?$AA@NNGAKEGL@ DB '0', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ DB 'c:'
	DB	'\radasm\wdk\projects\driver_projects\pdlr10_gladyr\ipackfltr\'
	DB	'ipackfltr.c', 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ DB 'E'
	DB	'X: Pageable code called at IRQL %d', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _CreateDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CreateDispatchRoutine@8 PROC				; COMDAT

; 73   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 74   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 75   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CreateDisp
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	75					; 0000004bH
	push	OFFSET ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CreateDisp:

; 76   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CreateDisp
	push	0
	push	76					; 0000004cH
	push	OFFSET ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CreateDisp
$LN4@CreateDisp:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CreateDisp:

; 77   : 
; 78   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 79   : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 80   : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 81   : 	return STATUS_SUCCESS;

	xor	eax, eax

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateDispatchRoutine@8 ENDP
; Function compile flags: /Odtp
PAGE	ENDS
;	COMDAT _CloseDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CloseDispatchRoutine@8 PROC				; COMDAT

; 87   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 88   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 89   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CloseDispa
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	89					; 00000059H
	push	OFFSET ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CloseDispa:

; 90   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CloseDispa
	push	0
	push	90					; 0000005aH
	push	OFFSET ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CloseDispa
$LN4@CloseDispa:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CloseDispa:

; 91   : 
; 92   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 93   : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 94   : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 95   : 	return STATUS_SUCCESS;

	xor	eax, eax

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CloseDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0DM@LMEPMJHO@ReadDispatchRoutine?3Output?5buffe@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp_@ExfInterlockedRemoveHeadList@8:PROC
;	COMDAT ??_C@_0DM@LMEPMJHO@ReadDispatchRoutine?3Output?5buffe@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DM@LMEPMJHO@ReadDispatchRoutine?3Output?5buffe@NNGAKEGL@ DB 'ReadD'
	DB	'ispatchRoutine:Output buffer length = %d less than %d', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _ReadDispatchRoutine@8
PAGE	SEGMENT
_outBufLen$ = -36					; size = 4
_status$ = -32						; size = 4
_packetsListEntry$ = -28				; size = 4
_ioStack$ = -24						; size = 4
_packetsCount$ = -20					; size = 4
_packetsPerBuffer$ = -16				; size = 4
_outBuf$ = -12						; size = 4
_packetsListItem$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ReadDispatchRoutine@8 PROC				; COMDAT

; 101  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 102  : 	NTSTATUS				status			= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 103  : 	PIO_STACK_LOCATION		ioStack			= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 104  : 	PDEVICE_EXTENSION		devExt			= DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _devExt$[ebp], edx

; 105  : 	ULONG					outBufLen		= ioStack->Parameters.Read.Length;

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _outBufLen$[ebp], ecx

; 106  : 	PCHAR					outBuf			= Irp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _outBuf$[ebp], eax

; 107  : 	PLIST_ENTRY				packetsListEntry	= NULL;	

	mov	DWORD PTR _packetsListEntry$[ebp], 0

; 108  : 	IP_HEADER_LIST*			packetsListItem	= NULL;

	mov	DWORD PTR _packetsListItem$[ebp], 0

; 109  : 	ULONG					packetsCount		= 0;

	mov	DWORD PTR _packetsCount$[ebp], 0

; 110  : 	ULONG					packetsPerBuffer	= 0;	

	mov	DWORD PTR _packetsPerBuffer$[ebp], 0

; 111  : 	
; 112  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	cmp	ecx, 1
	jle	SHORT $LN7@ReadDispat
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	push	edx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	112					; 00000070H
	push	OFFSET ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN7@ReadDispat:

; 113  : 	
; 114  : 	__debugbreak();

	int	3

; 115  : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 116  : 	
; 117  : 	if ( outBufLen < sizeof(IPHeader) )

	cmp	DWORD PTR _outBufLen$[ebp], 20		; 00000014H
	jae	SHORT $LN6@ReadDispat

; 118  : 	{
; 119  : 		KdPrint(( __FUNCTION__":Output buffer length = %d less than %d\n", 
; 120  : 				outBufLen, sizeof(IPHeader) ));		

	push	20					; 00000014H
	mov	ecx, DWORD PTR _outBufLen$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DM@LMEPMJHO@ReadDispatchRoutine?3Output?5buffe@NNGAKEGL@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 121  : 		status = STATUS_BUFFER_TOO_SMALL;

	mov	DWORD PTR _status$[ebp], -1073741789	; c0000023H

; 122  : 	}
; 123  : 	else

	jmp	$LN5@ReadDispat
$LN6@ReadDispat:

; 124  : 	{
; 125  : 		packetsPerBuffer = outBufLen / sizeof(IPHeader);

	mov	eax, DWORD PTR _outBufLen$[ebp]
	xor	edx, edx
	mov	ecx, 20					; 00000014H
	div	ecx
	mov	DWORD PTR _packetsPerBuffer$[ebp], eax

; 126  : 	 
; 127  : 		for( packetsCount = 0 ; packetsCount < packetsPerBuffer; packetsCount++)

	mov	DWORD PTR _packetsCount$[ebp], 0
	jmp	SHORT $LN4@ReadDispat
$LN3@ReadDispat:
	mov	edx, DWORD PTR _packetsCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _packetsCount$[ebp], edx
$LN4@ReadDispat:
	mov	eax, DWORD PTR _packetsCount$[ebp]
	cmp	eax, DWORD PTR _packetsPerBuffer$[ebp]
	jae	SHORT $LN5@ReadDispat

; 128  : 		{
; 129  : 			packetsListEntry = ExInterlockedRemoveHeadList(
; 130  : 												&gPacketsListHead,
; 131  : 												&gListSpinLock	); 			

	mov	edx, OFFSET _gListSpinLock
	mov	ecx, OFFSET _gPacketsListHead
	call	DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
	mov	DWORD PTR _packetsListEntry$[ebp], eax

; 132  : 			if(NULL == packetsListEntry)

	cmp	DWORD PTR _packetsListEntry$[ebp], 0
	jne	SHORT $LN1@ReadDispat

; 133  : 				break;

	jmp	SHORT $LN5@ReadDispat
$LN1@ReadDispat:

; 134  : 			
; 135  : 			packetsListItem = CONTAINING_RECORD(packetsListEntry,
; 136  : 												IP_HEADER_LIST,	ListEntry);

	mov	ecx, DWORD PTR _packetsListEntry$[ebp]
	mov	DWORD PTR _packetsListItem$[ebp], ecx

; 137  : 			RtlCopyMemory(outBuf, (char*)&packetsListItem->IPHeaderItem, sizeof(IPHeader));

	mov	edx, DWORD PTR _packetsListItem$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _outBuf$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx

; 138  : 			Irp->IoStatus.Information += sizeof(IPHeader); 

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 139  : 			ExFreePool(packetsListItem);

	push	0
	mov	eax, DWORD PTR _packetsListItem$[ebp]
	push	eax
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 140  : 		}

	jmp	SHORT $LN3@ReadDispat
$LN5@ReadDispat:

; 141  : 	}
; 142  : 	Irp->IoStatus.Status = status;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 143  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 144  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_ReadDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ DB 'c:\win'
	DB	'ddk\inc\ddk\wdm.h', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	push	0
	push	23317					; 00005b15H
	push	OFFSET ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
	push	OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 23319: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_SetIpPacketsFilter@8
; Function compile flags: /Odtp
; File c:\radasm\wdk\projects\driver_projects\pdlr10_gladyr\ipackfltr\ipackfltr.c
;	COMDAT _DeviceControlDispatchRoutine@8
PAGE	SEGMENT
tv80 = -24						; size = 4
_status$ = -20						; size = 4
_packetsListEntry$ = -16				; size = 4
_ioStack$ = -12						; size = 4
_packetsListItem$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DeviceControlDispatchRoutine@8 PROC			; COMDAT

; 150  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 151  : 	NTSTATUS				status			= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 152  : 	PIO_STACK_LOCATION		ioStack			= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 153  : 	PDEVICE_EXTENSION		devExt			= DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _devExt$[ebp], edx

; 154  : 	PLIST_ENTRY				packetsListEntry	= NULL;	

	mov	DWORD PTR _packetsListEntry$[ebp], 0

; 155  : 	IP_HEADER_LIST*			packetsListItem	= NULL;

	mov	DWORD PTR _packetsListItem$[ebp], 0

; 156  : 
; 157  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN8@DeviceCont
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	157					; 0000009dH
	push	OFFSET ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN8@DeviceCont:

; 158  : 	
; 159  : 	__debugbreak();

	int	3

; 160  : 	Irp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 161  : 	switch(ioStack->Parameters.DeviceIoControl.IoControlCode)

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 2236416		; 00222000H
	je	SHORT $LN5@DeviceCont
	cmp	DWORD PTR tv80[ebp], 2236420		; 00222004H
	je	SHORT $LN4@DeviceCont
	jmp	SHORT $LN1@DeviceCont
$LN5@DeviceCont:

; 162  : 	{
; 163  : 		case IOCTL_SET_FILTER:
; 164  : 			status = SetIpPacketsFilter(DeviceObject, TRUE);

	push	1
	mov	edx, DWORD PTR _DeviceObject$[ebp]
	push	edx
	call	_SetIpPacketsFilter@8
	mov	DWORD PTR _status$[ebp], eax

; 165  : 			break;

	jmp	SHORT $LN6@DeviceCont
$LN4@DeviceCont:

; 166  : 		
; 167  : 		case IOCTL_RESET_FILTER:
; 168  : 			status = SetIpPacketsFilter(DeviceObject, FALSE);

	push	0
	mov	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	call	_SetIpPacketsFilter@8
	mov	DWORD PTR _status$[ebp], eax
$LN3@DeviceCont:

; 169  : 			while( NULL != (packetsListEntry = ExInterlockedRemoveHeadList(
; 170  : 												&gPacketsListHead,
; 171  : 												&gListSpinLock	))) 			

	mov	edx, OFFSET _gListSpinLock
	mov	ecx, OFFSET _gPacketsListHead
	call	DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
	mov	DWORD PTR _packetsListEntry$[ebp], eax
	cmp	DWORD PTR _packetsListEntry$[ebp], 0
	je	SHORT $LN2@DeviceCont

; 172  : 			{
; 173  : 				packetsListItem = CONTAINING_RECORD(packetsListEntry,
; 174  : 											IP_HEADER_LIST,	ListEntry);

	mov	ecx, DWORD PTR _packetsListEntry$[ebp]
	mov	DWORD PTR _packetsListItem$[ebp], ecx

; 175  : 				ExFreePool(packetsListItem);

	push	0
	mov	edx, DWORD PTR _packetsListItem$[ebp]
	push	edx
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 176  : 			}

	jmp	SHORT $LN3@DeviceCont
$LN2@DeviceCont:

; 177  : 			break;

	jmp	SHORT $LN6@DeviceCont
$LN1@DeviceCont:

; 178  : 
; 179  : 		default:
; 180  : 			status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H
$LN6@DeviceCont:

; 181  : 			break;
; 182  : 	}	
; 183  : 		
; 184  : 	Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 185  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 186  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DeviceControlDispatchRoutine@8 ENDP
PAGE	ENDS
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
; Function compile flags: /Odtp
;	COMDAT _DriverUnload@4
PAGE	SEGMENT
_packetsListEntry$ = -16				; size = 4
_DeviceObject$ = -12					; size = 4
_packetsListItem$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_DriverUnload@4 PROC					; COMDAT

; 191  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 192  : 	PDEVICE_OBJECT		DeviceObject		= DriverObject->DeviceObject;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _DeviceObject$[ebp], ecx

; 193  : 	PDEVICE_EXTENSION	devExt			= DeviceObject->DeviceExtension;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _devExt$[ebp], eax

; 194  : 	PLIST_ENTRY			packetsListEntry	= NULL;	

	mov	DWORD PTR _packetsListEntry$[ebp], 0

; 195  : 	IP_HEADER_LIST*		packetsListItem	= NULL;

	mov	DWORD PTR _packetsListItem$[ebp], 0

; 196  : 	
; 197  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	cmp	ecx, 1
	jle	SHORT $LN3@DriverUnlo
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	push	edx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	197					; 000000c5H
	push	OFFSET ??_C@_0EL@NGJGILKG@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN3@DriverUnlo:

; 198  : 	
; 199  : 	SetIpPacketsFilter(DeviceObject, FALSE);

	push	0
	mov	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	call	_SetIpPacketsFilter@8
$LN2@DriverUnlo:

; 200  : 		
; 201  : 	while( NULL != (packetsListEntry = ExInterlockedRemoveHeadList(
; 202  : 												&gPacketsListHead,
; 203  : 												&gListSpinLock	))) 			

	mov	edx, OFFSET _gListSpinLock
	mov	ecx, OFFSET _gPacketsListHead
	call	DWORD PTR __imp_@ExfInterlockedRemoveHeadList@8
	mov	DWORD PTR _packetsListEntry$[ebp], eax
	cmp	DWORD PTR _packetsListEntry$[ebp], 0
	je	SHORT $LN1@DriverUnlo

; 204  : 	{
; 205  : 		packetsListItem = CONTAINING_RECORD(packetsListEntry,
; 206  : 											IP_HEADER_LIST,	ListEntry);

	mov	ecx, DWORD PTR _packetsListEntry$[ebp]
	mov	DWORD PTR _packetsListItem$[ebp], ecx

; 207  : 		ExFreePool(packetsListItem);

	push	0
	mov	edx, DWORD PTR _packetsListItem$[ebp]
	push	edx
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 208  : 	}

	jmp	SHORT $LN2@DriverUnlo
$LN1@DriverUnlo:

; 209  : 
; 210  : 	ObDereferenceObject(devExt->IpFltrFileObj);

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_@ObfDereferenceObject@4

; 211  : 	IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 212  : 	IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 213  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DriverUnload@4 ENDP
PAGE	ENDS
PUBLIC	_IpPacketsFilter@28
EXTRN	__imp_@ExfInterlockedInsertTailList@12:PROC
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
; Function compile flags: /Odtp
;	COMDAT _IpPacketsFilter@28
_TEXT	SEGMENT
_packetsListItem$ = -4					; size = 4
_PacketHeader$ = 8					; size = 4
_Packet$ = 12						; size = 4
_PacketLength$ = 16					; size = 4
_RecvInterfaceIndex$ = 20				; size = 4
_SendInterfaceIndex$ = 24				; size = 4
_RecvLinkNextHop$ = 28					; size = 4
_SendLinkNextHop$ = 32					; size = 4
_IpPacketsFilter@28 PROC				; COMDAT

; 223  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 224  : 	IP_HEADER_LIST*		packetsListItem = NULL;

	mov	DWORD PTR _packetsListItem$[ebp], 0

; 225  : 			
; 226  : 	packetsListItem = (IP_HEADER_LIST*)ExAllocatePoolWithTag( 
; 227  : 										NonPagedPool, 
; 228  : 										sizeof(IP_HEADER_LIST), 
; 229  : 										TAG);

	push	1816555593				; 6c467049H
	push	28					; 0000001cH
	push	0
	call	DWORD PTR __imp__ExAllocatePoolWithTag@12
	mov	DWORD PTR _packetsListItem$[ebp], eax

; 230  : 	if(packetsListItem)

	cmp	DWORD PTR _packetsListItem$[ebp], 0
	je	SHORT $LN1@IpPacketsF

; 231  : 	{
; 232  : 		
; 233  : 		RtlCopyMemory( (char*)&packetsListItem->IPHeaderItem, 
; 234  : 						PacketHeader, sizeof(IPHeader) );

	mov	eax, DWORD PTR _packetsListItem$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _PacketHeader$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx

; 235  : 		ExInterlockedInsertTailList(	&gPacketsListHead, 
; 236  : 								&packetsListItem->ListEntry, 
; 237  : 								&gListSpinLock);	

	push	OFFSET _gListSpinLock
	mov	edx, DWORD PTR _packetsListItem$[ebp]
	mov	ecx, OFFSET _gPacketsListHead
	call	DWORD PTR __imp_@ExfInterlockedInsertTailList@12
$LN1@IpPacketsF:

; 238  : 	}	
; 239  : 	return PF_FORWARD;	

	xor	eax, eax

; 240  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_IpPacketsFilter@28 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@FHHDLLGA@SetIpPacketsFilter?5return?5status@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DH@GHAHAHNJ@SetIpPacketsFilter?3IoCallDriver?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DI@COLJNNLF@SetIpPacketsFilter?3IoBuildDevice@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp_@IofCallDriver@8:PROC
EXTRN	__imp__IoBuildDeviceIoControlRequest@36:PROC
;	COMDAT ??_C@_0CL@FHHDLLGA@SetIpPacketsFilter?5return?5status@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@FHHDLLGA@SetIpPacketsFilter?5return?5status@FNODOBFM@ DB 'SetIp'
	DB	'PacketsFilter return status = 0x%08X', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DH@GHAHAHNJ@SetIpPacketsFilter?3IoCallDriver?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DH@GHAHAHNJ@SetIpPacketsFilter?3IoCallDriver?5@FNODOBFM@ DB 'SetIp'
	DB	'PacketsFilter:IoCallDriver return STATUS_PENDING', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DI@COLJNNLF@SetIpPacketsFilter?3IoBuildDevice@FNODOBFM@
text$s	SEGMENT
??_C@_0DI@COLJNNLF@SetIpPacketsFilter?3IoBuildDevice@FNODOBFM@ DB 'SetIpP'
	DB	'acketsFilter:IoBuildDeviceIoControlRequest fails', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _SetIpPacketsFilter@8
_TEXT	SEGMENT
_status$ = -12						; size = 4
_ipFltrIrp$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_state$ = 12						; size = 1
_SetIpPacketsFilter@8 PROC				; COMDAT

; 245  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 246  : 	PDEVICE_EXTENSION		devExt		= DeviceObject->DeviceExtension;

	mov	eax, DWORD PTR _DeviceObject$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _devExt$[ebp], ecx

; 247  : 	PIRP					ipFltrIrp		= NULL;

	mov	DWORD PTR _ipFltrIrp$[ebp], 0

; 248  : 	NTSTATUS				status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 249  : 		
; 250  : //	if( NT_SUCCESS(devExt->IpFltrStatus.Status) )
; 251  : //	{
; 252  : //		return  devExt->IpFltrStatus.Status;
; 253  : //	}
; 254  : 
; 255  : 	if(state)

	movzx	edx, BYTE PTR _state$[ebp]
	test	edx, edx
	je	SHORT $LN4@SetIpPacke

; 256  : 	{
; 257  : 		devExt->IpFltrExtHook.ExtensionPointer = IpPacketsFilter;	

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+32], OFFSET _IpPacketsFilter@28

; 258  : 	}
; 259  : 	else

	jmp	SHORT $LN3@SetIpPacke
$LN4@SetIpPacke:

; 260  : 	{
; 261  : 		devExt->IpFltrExtHook.ExtensionPointer = 0;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+32], 0
$LN3@SetIpPacke:

; 262  : 	}
; 263  : 	
; 264  : 	ipFltrIrp = IoBuildDeviceIoControlRequest(
; 265  : 						IOCTL_PF_SET_EXTENSION_POINTER, 
; 266  : 						devExt->IpFltrDevObj, 
; 267  : 						&devExt->IpFltrExtHook, 
; 268  : 						sizeof(devExt->IpFltrExtHook), 
; 269  : 						NULL,  0, FALSE, NULL, 
; 270  : 						&devExt->IpFltrStatus	);     

	mov	edx, DWORD PTR _devExt$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	1212504					; 00128058H
	call	DWORD PTR __imp__IoBuildDeviceIoControlRequest@36
	mov	DWORD PTR _ipFltrIrp$[ebp], eax

; 271  : 
; 272  : 		if ( !ipFltrIrp )

	cmp	DWORD PTR _ipFltrIrp$[ebp], 0
	jne	SHORT $LN2@SetIpPacke

; 273  : 		{
; 274  : 			KdPrint( (__FUNCTION__":IoBuildDeviceIoControlRequest fails\n") );

	push	OFFSET ??_C@_0DI@COLJNNLF@SetIpPacketsFilter?3IoBuildDevice@FNODOBFM@
	call	_DbgPrint
	add	esp, 4

; 275  : 			return STATUS_INSUFFICIENT_RESOURCES;

	mov	eax, -1073741670			; c000009aH
	jmp	SHORT $LN5@SetIpPacke
$LN2@SetIpPacke:

; 276  : 		}
; 277  : 			
; 278  : 		status = IoCallDriver(devExt->IpFltrDevObj, ipFltrIrp);

	mov	edx, DWORD PTR _ipFltrIrp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_@IofCallDriver@8
	mov	DWORD PTR _status$[ebp], eax

; 279  : 		if ( STATUS_PENDING == status)

	cmp	DWORD PTR _status$[ebp], 259		; 00000103H
	jne	SHORT $LN1@SetIpPacke

; 280  : 		{
; 281  : 			KdPrint((__FUNCTION__":IoCallDriver return STATUS_PENDING\n"));

	push	OFFSET ??_C@_0DH@GHAHAHNJ@SetIpPacketsFilter?3IoCallDriver?5@FNODOBFM@
	call	_DbgPrint
	add	esp, 4

; 282  : 			KeWaitForSingleObject(&devExt->IpFltrEvent, 
; 283  : 								UserRequest, 
; 284  : 								KernelMode, FALSE, NULL	);

	push	0
	push	0
	push	0
	push	6
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 8
	push	ecx
	call	DWORD PTR __imp__KeWaitForSingleObject@20
$LN1@SetIpPacke:

; 285  : 		}
; 286  : 		KdPrint((__FUNCTION__" return status = 0x%08X\n", devExt->IpFltrStatus.Status));

	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET ??_C@_0CL@FHHDLLGA@SetIpPacketsFilter?5return?5status@FNODOBFM@
	call	_DbgPrint
	add	esp, 8

; 287  : 		return  devExt->IpFltrStatus.Status;			

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [ecx+24]
$LN5@SetIpPacke:

; 288  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SetIpPacketsFilter@8 ENDP
_TEXT	ENDS
END
