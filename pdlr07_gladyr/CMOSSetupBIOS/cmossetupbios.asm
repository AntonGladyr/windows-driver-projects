; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr07_gladyr\cmossetupbios\cmossetupbios.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deviceName_buffer
PUBLIC	_deviceName
PUBLIC	_symbolicLinkName_buffer
PUBLIC	_symbolicLinkName
CONST	SEGMENT
_deviceName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, '\', 00H, 'C', 00H, 'M', 00H, 'O', 00H, 'S', 00H
	DB	'S', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'p', 00H, 'B', 00H, 'I'
	DB	00H, 'O', 00H, 'S', 00H, 00H, 00H
_deviceName DW	02aH
	DW	02cH
	DD	FLAT:_deviceName_buffer
_symbolicLinkName_buffer DB '\', 00H, '?', 00H, '?', 00H, '\', 00H, 'C', 00H
	DB	'M', 00H, 'O', 00H, 'S', 00H, 'S', 00H, 'e', 00H, 't', 00H, 'u'
	DB	00H, 'p', 00H, 'B', 00H, 'I', 00H, 'O', 00H, 'S', 00H, 00H, 00H
_symbolicLinkName DW 022H
	DW	024H
	DD	FLAT:_symbolicLinkName_buffer
CONST	ENDS
PUBLIC	_IoGetCurrentIrpStackLocation@4
; Function compile flags: /Ogsp
; File c:\winddk\inc\ddk\wdm.h
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [eax+96]

; 23319: }

	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_CreateCloseDispatchRoutine@8
EXTRN	__imp_@IofCompleteRequest@8:PROC
; Function compile flags: /Ogsp
; File c:\radasm\wdk\projects\driver_projects\pdlr07_gladyr\cmossetupbios\cmossetupbios.c
;	COMDAT _CreateCloseDispatchRoutine@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CreateCloseDispatchRoutine@8 PROC			; COMDAT

; 46   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 47   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 48   : 	PAGED_CODE();
; 49   : 	ASSERT(Irp);
; 50   : 
; 51   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	ecx, DWORD PTR _Irp$[ebp]
	and	DWORD PTR [ecx+24], 0

; 52   : 	Irp->IoStatus.Information = 0;

	and	DWORD PTR [ecx+28], 0

; 53   : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 54   : 	return STATUS_SUCCESS;

	xor	eax, eax

; 55   : }

	pop	ebp
	ret	8
_CreateCloseDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	_DeviceControlDispatchRoutine@8
EXTRN	__imp__READ_PORT_UCHAR@4:PROC
EXTRN	__imp__WRITE_PORT_UCHAR@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _DeviceControlDispatchRoutine@8
PAGE	SEGMENT
_status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DeviceControlDispatchRoutine@8 PROC			; COMDAT

; 60   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 61   : 	NTSTATUS					status		= STATUS_SUCCESS;

	and	DWORD PTR _status$[ebp], 0
	push	ebx
	push	esi

; 62   : 	PIO_STACK_LOCATION			ioStack		= IoGetCurrentIrpStackLocation(Irp);

	mov	esi, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [esi+96]

; 63   : 	ULONG						inBufLen		= ioStack->Parameters.DeviceIoControl.InputBufferLength;

	mov	ecx, DWORD PTR [eax+8]

; 64   : 	ULONG						outBufLen	= ioStack->Parameters.DeviceIoControl.OutputBufferLength;

	mov	edx, DWORD PTR [eax+4]

; 65   : 	PCHAR               				inBuf		= Irp->AssociatedIrp.SystemBuffer;
; 66   : 	PCHAR               				outBuf		= Irp->AssociatedIrp.SystemBuffer;
; 67   : 	UCHAR						secondsIndex = 0x00;
; 68   : 
; 69   : 	PAGED_CODE();
; 70   : 	
; 71   : 	Irp->IoStatus.Information = 0;

	and	DWORD PTR [esi+28], 0

; 72   : 	switch(ioStack->Parameters.DeviceIoControl.IoControlCode)

	mov	eax, DWORD PTR [eax+12]
	sub	eax, 2236416				; 00222000H
	push	edi
	mov	edi, DWORD PTR [esi+12]
	je	$LN10@DeviceCont
	sub	eax, 4
	je	SHORT $LN8@DeviceCont
	sub	eax, 4
	je	SHORT $LN5@DeviceCont
	sub	eax, 4
	je	SHORT $LN3@DeviceCont

; 227  : 			
; 228  : 		default:
; 229  : 			status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H

; 230  : 			break;

	jmp	$LN11@DeviceCont
$LN3@DeviceCont:

; 199  : 			
; 200  : 		case IOCTL_GET_STATUS_REGISTER_D:
; 201  : 			if( outBufLen != sizeof(UCHAR) )

	xor	ebx, ebx
	inc	ebx
	cmp	edx, ebx

; 202  : 			{
; 203  : 				KdPrint( (__FUNCTION__":Output buffer length = %d invalid\n", inBufLen) );
; 204  : 				status = STATUS_INVALID_PARAMETER;
; 205  : 				break;

	jne	$LN19@DeviceCont

; 206  : 			}
; 207  : 			
; 208  : #pragma warning(push)
; 209  : #pragma warning(disable: 28138)
; 210  : /*
; 211  : 28138 - The constant argument <operand> should instead be variable
; 212  : The driver is calling a function that expects a variable or a non-constant 
; 213  : expression, but the call includes a constant. For example, the parameter 
; 214  : of the READ_PORT_ ... /WRITE_PORT_... macro must be a pointer to the 
; 215  : port address, not the address provided as a constant.
; 216  : There are a few older devices for which a constant parameter is acceptable
; 217  : with  the READ_PORT and WRITE_PORT family of functions. When those 
; 218  : devices receive this warning, the warning can be suppressed or ignored.
; 219  : */
; 220  : 			
; 221  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x0D);

	push	13					; 0000000dH

; 222  : 			*outBuf = READ_PORT_UCHAR((PUCHAR)0x71);
; 223  : 			Irp->IoStatus.Information =  sizeof(UCHAR);
; 224  : 			
; 225  : #pragma warning(pop)
; 226  : 			break;

	jmp	SHORT $LN20@DeviceCont
$LN5@DeviceCont:

; 171  : 			
; 172  : 		case IOCTL_GET_DIAGNOSTIC_STATUS:
; 173  : 			if( outBufLen != sizeof(UCHAR) )

	xor	ebx, ebx
	inc	ebx
	cmp	edx, ebx

; 174  : 			{
; 175  : 				KdPrint( (__FUNCTION__":Output buffer length = %d invalid\n", inBufLen) );
; 176  : 				status = STATUS_INVALID_PARAMETER;
; 177  : 				break;

	jne	$LN19@DeviceCont

; 178  : 			}
; 179  : 			
; 180  : #pragma warning(push)
; 181  : #pragma warning(disable: 28138)
; 182  : /*
; 183  : 28138 - The constant argument <operand> should instead be variable
; 184  : The driver is calling a function that expects a variable or a non-constant 
; 185  : expression, but the call includes a constant. For example, the parameter 
; 186  : of the READ_PORT_ ... /WRITE_PORT_... macro must be a pointer to the 
; 187  : port address, not the address provided as a constant.
; 188  : There are a few older devices for which a constant parameter is acceptable
; 189  : with  the READ_PORT and WRITE_PORT family of functions. When those 
; 190  : devices receive this warning, the warning can be suppressed or ignored.
; 191  : */
; 192  : 			
; 193  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x0E);

	push	14					; 0000000eH
$LN20@DeviceCont:
	push	112					; 00000070H
	call	DWORD PTR __imp__WRITE_PORT_UCHAR@8

; 194  : 			*outBuf = READ_PORT_UCHAR((PUCHAR)0x71);

	push	113					; 00000071H
	call	DWORD PTR __imp__READ_PORT_UCHAR@4
	mov	BYTE PTR [edi], al

; 195  : 			Irp->IoStatus.Information =  sizeof(UCHAR);

	mov	DWORD PTR [esi+28], ebx

; 196  : 			
; 197  : #pragma warning(pop)
; 198  : 			break;

	jmp	$LN11@DeviceCont
$LN8@DeviceCont:

; 110  : 			
; 111  : #pragma warning(pop)	
; 112  : 			break;
; 113  : 			
; 114  : 		case IOCTL_SET_NEW_DATE_TIME:
; 115  : 			if( inBufLen != 6 * sizeof(UCHAR) )

	cmp	ecx, 6

; 116  : 			{
; 117  : 				KdPrint( (__FUNCTION__":Input buffer length = %d invalid\n", inBufLen) );
; 118  : 				status = STATUS_INVALID_PARAMETER;
; 119  : 				break;

	jne	SHORT $LN19@DeviceCont

; 120  : 			}
; 121  : 			if( outBufLen != 6 * sizeof(UCHAR) )

	cmp	edx, ecx

; 122  : 			{
; 123  : 				KdPrint( (__FUNCTION__":Output buffer length = %d invalid\n", outBufLen) );
; 124  : 				status = STATUS_INVALID_PARAMETER;
; 125  : 				break;

	jne	SHORT $LN19@DeviceCont

; 126  : 			}
; 127  : 			
; 128  : #pragma warning(push)
; 129  : #pragma warning(disable: 28138)
; 130  : /*
; 131  : 28138 - The constant argument <operand> should instead be variable
; 132  : The driver is calling a function that expects a variable or a non-constant 
; 133  : expression, but the call includes a constant. For example, the parameter 
; 134  : of the READ_PORT_ ... /WRITE_PORT_... macro must be a pointer to the 
; 135  : port address, not the address provided as a constant.
; 136  : There are a few older devices for which a constant parameter is acceptable
; 137  : with  the READ_PORT and WRITE_PORT family of functions. When those 
; 138  : devices receive this warning, the warning can be suppressed or ignored.
; 139  : */
; 140  : 			// set new date and time
; 141  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x07);

	mov	esi, DWORD PTR __imp__WRITE_PORT_UCHAR@8
	push	7
	push	112					; 00000070H
	call	esi

; 142  : 			WRITE_PORT_UCHAR((PUCHAR)0x71, *inBuf);

	movzx	eax, BYTE PTR [edi]
	push	eax
	push	113					; 00000071H
	pop	ebx
	push	ebx
	call	esi

; 143  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x08);

	push	8
	push	112					; 00000070H
	call	esi

; 144  : 			WRITE_PORT_UCHAR((PUCHAR)0x71, *(inBuf + 1));

	movzx	eax, BYTE PTR [edi+1]
	push	eax
	push	ebx
	call	esi

; 145  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x09);

	push	9
	push	112					; 00000070H
	call	esi

; 146  : 			WRITE_PORT_UCHAR((PUCHAR)0x71, *(inBuf + 2));

	movzx	eax, BYTE PTR [edi+2]
	push	eax
	push	ebx
	call	esi

; 147  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x04);

	push	4
	push	112					; 00000070H
	call	esi

; 148  : 			WRITE_PORT_UCHAR((PUCHAR)0x71, *(inBuf + 3));

	movzx	eax, BYTE PTR [edi+3]
	push	eax
	push	ebx
	call	esi

; 149  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x02);

	push	2
	push	112					; 00000070H
	call	esi

; 150  : 			WRITE_PORT_UCHAR((PUCHAR)0x71, *(inBuf + 4));

	movzx	eax, BYTE PTR [edi+4]
	push	eax
	push	ebx
	call	esi

; 151  : 			//WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x00);
; 152  : 			//WRITE_PORT_UCHAR((PUCHAR)0x71, *(inBuf + 5));
; 153  : 			
; 154  : 			// read date and time
; 155  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x07);

	push	7
	push	112					; 00000070H
	call	esi

; 156  : 			*outBuf = READ_PORT_UCHAR((PUCHAR)0x71);

	push	ebx

; 157  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x08);
; 158  : 			*(outBuf + 1) = READ_PORT_UCHAR((PUCHAR)0x71);
; 159  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x09);
; 160  : 			*(outBuf + 2) = READ_PORT_UCHAR((PUCHAR)0x71);
; 161  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x04);
; 162  : 			*(outBuf + 3) = READ_PORT_UCHAR((PUCHAR)0x71);
; 163  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x02);
; 164  : 			*(outBuf + 4) = READ_PORT_UCHAR((PUCHAR)0x71);
; 165  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x00);
; 166  : 			*(outBuf + 5) = READ_PORT_UCHAR((PUCHAR)0x71);
; 167  : 			Irp->IoStatus.Information = 6 * sizeof(UCHAR);
; 168  : 
; 169  : #pragma warning(pop)
; 170  : 			break;

	jmp	SHORT $LN18@DeviceCont
$LN10@DeviceCont:

; 73   : 	{
; 74   : 		case IOCTL_GET_CURRENT_DATE_TIME:
; 75   : 		//Перевіряємо розміри буферів. Розмір вхідного і вихідного буферів та їх 
; 76   : 		//наявність взагалі для кожного IOCTL-запиту в ЗАГАЛЬНОМУ ВИПАДКУ РІЗНИЙ
; 77   : 			if( outBufLen != 6 * sizeof(UCHAR) )

	cmp	edx, 6
	je	SHORT $LN9@DeviceCont
$LN19@DeviceCont:

; 78   : 			{
; 79   : 				KdPrint( (__FUNCTION__":Output buffer length = %d invalid\n", inBufLen) );
; 80   : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 81   : 				break;

	jmp	SHORT $LN11@DeviceCont
$LN9@DeviceCont:

; 82   : 			}
; 83   : 
; 84   : #pragma warning(push)
; 85   : #pragma warning(disable: 28138)
; 86   : /*
; 87   : 28138 - The constant argument <operand> should instead be variable
; 88   : The driver is calling a function that expects a variable or a non-constant 
; 89   : expression, but the call includes a constant. For example, the parameter 
; 90   : of the READ_PORT_ ... /WRITE_PORT_... macro must be a pointer to the 
; 91   : port address, not the address provided as a constant.
; 92   : There are a few older devices for which a constant parameter is acceptable
; 93   : with  the READ_PORT and WRITE_PORT family of functions. When those 
; 94   : devices receive this warning, the warning can be suppressed or ignored.
; 95   : */
; 96   : 			
; 97   : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x07);

	mov	esi, DWORD PTR __imp__WRITE_PORT_UCHAR@8
	push	7
	push	112					; 00000070H
	call	esi

; 98   : 			*outBuf = READ_PORT_UCHAR((PUCHAR)0x71);

	push	113					; 00000071H
$LN18@DeviceCont:
	mov	ebx, DWORD PTR __imp__READ_PORT_UCHAR@4
	call	ebx

; 99   : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x08);

	push	8
	push	112					; 00000070H
	mov	BYTE PTR [edi], al
	call	esi

; 100  : 			*(outBuf + 1) = READ_PORT_UCHAR((PUCHAR)0x71);

	push	113					; 00000071H
	call	ebx

; 101  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x09);

	push	9
	push	112					; 00000070H
	mov	BYTE PTR [edi+1], al
	call	esi

; 102  : 			*(outBuf + 2) = READ_PORT_UCHAR((PUCHAR)0x71);

	push	113					; 00000071H
	call	ebx

; 103  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x04);

	push	4
	push	112					; 00000070H
	mov	BYTE PTR [edi+2], al
	call	esi

; 104  : 			*(outBuf + 3) = READ_PORT_UCHAR((PUCHAR)0x71);

	push	113					; 00000071H
	call	ebx

; 105  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x02);

	push	2
	push	112					; 00000070H
	mov	BYTE PTR [edi+3], al
	call	esi

; 106  : 			*(outBuf + 4) = READ_PORT_UCHAR((PUCHAR)0x71);

	push	113					; 00000071H
	call	ebx

; 107  : 			WRITE_PORT_UCHAR((PUCHAR)0x70, (UCHAR)0x00);

	push	0
	push	112					; 00000070H
	mov	BYTE PTR [edi+4], al
	call	esi

; 108  : 			*(outBuf + 5) = READ_PORT_UCHAR((PUCHAR)0x71);

	push	113					; 00000071H
	call	ebx
	mov	BYTE PTR [edi+5], al

; 109  : 			Irp->IoStatus.Information = 6 * sizeof(UCHAR);

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	esi, eax
	mov	DWORD PTR [eax+28], 6
$LN11@DeviceCont:

; 231  : 	}	
; 232  : 		
; 233  : 	Irp->IoStatus.Status = status;

	mov	edi, DWORD PTR _status$[ebp]

; 234  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, esi
	mov	DWORD PTR [esi+24], edi
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 235  : 	return status;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 236  : }

	leave
	ret	8
_DeviceControlDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	_DriverUnload@4
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _DriverUnload@4
PAGE	SEGMENT
_DriverObject$ = 8					; size = 4
_DriverUnload@4 PROC					; COMDAT

; 240  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 241  : 	PDEVICE_OBJECT	DeviceObject = DriverObject->DeviceObject;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	push	esi
	mov	esi, DWORD PTR [eax+4]

; 242  : 
; 243  : 	PAGED_CODE();
; 244  : 
; 245  : 	IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 246  : 	if (DeviceObject != NULL)

	test	esi, esi
	je	SHORT $LN1@DriverUnlo

; 247  : 	{
; 248  : 		IoDeleteDevice(DeviceObject);

	push	esi
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN1@DriverUnlo:
	pop	esi

; 249  : 	}
; 250  : }

	pop	ebp
	ret	4
_DriverUnload@4 ENDP
PAGE	ENDS
PUBLIC	_DriverEntry@8
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
; Function compile flags: /Ogsp
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_DeviceObject$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 7    : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 8    : 	NTSTATUS		status			= STATUS_SUCCESS;
; 9    : 	PDEVICE_OBJECT	DeviceObject	= NULL;

	and	DWORD PTR _DeviceObject$[ebp], 0
	push	esi

; 10   : 
; 11   : 	UNREFERENCED_PARAMETER(RegistryPath);
; 12   : 
; 13   : 	status = IoCreateDevice(	DriverObject, 0,
; 14   : 							(PUNICODE_STRING)&deviceName,
; 15   : 							DEV_TYPE, FILE_DEVICE_SECURE_OPEN,
; 16   : 							FALSE, &DeviceObject );                        

	mov	esi, DWORD PTR _DriverObject$[ebp]
	push	edi
	lea	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	push	34					; 00000022H
	mov	edi, OFFSET _deviceName
	push	edi
	push	0
	push	esi
	call	DWORD PTR __imp__IoCreateDevice@28

; 17   : 	
; 18   : 	if (!NT_SUCCESS(status))

	test	eax, eax

; 19   : 	{
; 20   : 		KdPrint((__FUNCTION__":IoCreateDevice fails with status = 0x%08X for device with name %wZ\n", 
; 21   : 					status, (PUNICODE_STRING)&deviceName) );
; 22   : 		return status;

	jl	SHORT $LN3@DriverEntr

; 23   : 	}
; 24   : 	
; 25   : 	status = IoCreateSymbolicLink(	(PUNICODE_STRING)&symbolicLinkName, 
; 26   : 									(PUNICODE_STRING)&deviceName	);

	push	edi
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	edi, eax

; 27   : 		
; 28   : 	if (!NT_SUCCESS(status))

	test	edi, edi
	jge	SHORT $LN1@DriverEntr

; 29   : 	{
; 30   : 		KdPrint((__FUNCTION__":IoCreateSymbolicLink fails with status = 0x%08X\n", status));
; 31   : 		IoDeleteDevice(DeviceObject);

	push	DWORD PTR _DeviceObject$[ebp]
	call	DWORD PTR __imp__IoDeleteDevice@4

; 32   : 		return status;

	jmp	SHORT $LN5@DriverEntr
$LN1@DriverEntr:

; 33   : 	}
; 34   : 
; 35   : 	DriverObject->MajorFunction[IRP_MJ_CREATE]		= CreateCloseDispatchRoutine;

	mov	eax, OFFSET _CreateCloseDispatchRoutine@8
	mov	DWORD PTR [esi+56], eax

; 36   : 	DriverObject->MajorFunction[IRP_MJ_CLOSE]			= CreateCloseDispatchRoutine;

	mov	DWORD PTR [esi+64], eax

; 37   : 	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]	= DeviceControlDispatchRoutine;

	mov	DWORD PTR [esi+112], OFFSET _DeviceControlDispatchRoutine@8

; 38   : 	DriverObject->DriverUnload							= DriverUnload;

	mov	DWORD PTR [esi+52], OFFSET _DriverUnload@4
$LN5@DriverEntr:

; 39   : 
; 40   : 	return status;

	mov	eax, edi
$LN3@DriverEntr:
	pop	edi
	pop	esi

; 41   : }

	leave
	ret	8
_DriverEntry@8 ENDP
INIT	ENDS
END
