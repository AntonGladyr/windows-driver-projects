; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr09_gladyr\selfdefence\selfdefence.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deviceName_buffer
PUBLIC	_deviceName
PUBLIC	_symbolicLinkName_buffer
PUBLIC	_symbolicLinkName
_BSS	SEGMENT
_gZwOpenProcessNumber DD 01H DUP (?)
_gZwTerminateProcessNumber DD 01H DUP (?)
_gRealZwOpenProcess DD 01H DUP (?)
_gRealZwTerminateProcess DD 01H DUP (?)
_gOwnerPID DD	01H DUP (?)
_gActive DB	01H DUP (?)
	ALIGN	4

_gSSTMdl DD	01H DUP (?)
_gSSTAddr DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_deviceName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'l', 00H, 'f', 00H
	DB	'D', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e'
	DB	00H, 00H, 00H
_deviceName DW	026H
	DW	028H
	DD	FLAT:_deviceName_buffer
_symbolicLinkName_buffer DB '\', 00H, '?', 00H, '?', 00H, '\', 00H, 'S', 00H
	DB	'e', 00H, 'l', 00H, 'f', 00H, 'D', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'n', 00H, 'c', 00H, 'e', 00H, 00H, 00H
_symbolicLinkName DW 01eH
	DW	020H
	DD	FLAT:_symbolicLinkName_buffer
CONST	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_DeviceControlDispatchRoutine@8
PUBLIC	_CreateCloseDispatchRoutine@8
PUBLIC	??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0CC@ILDFKBLG@DriverEntry?5?3?5IoAllocateMdl?5fail@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0BB@OCFKBBEC@NtBuildNumber?$DN?$CFd?$AA@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	_DriverEntry@8
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
EXTRN	__imp__MmBuildMdlForNonPagedPool@4:PROC
EXTRN	__imp__IoAllocateMdl@20:PROC
EXTRN	_KeServiceDescriptorTable:DWORD
EXTRN	_DbgPrint:PROC
EXTRN	_NtBuildNumber:DWORD
;	COMDAT ??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@
; File c:\radasm\wdk\projects\driver_projects\pdlr09_gladyr\selfdefence\selfdefence.c
INIT$s	SEGMENT
??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@ DB 'Drive'
	DB	'rEntry : IoCreateSymbolicLink fails with status = 0x%08X', 0aH
	DB	00H						;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@
INIT$s	SEGMENT
??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@ DB 'Driv'
	DB	'erEntry : IoCreateDevice fails with status = 0x%08X for devic'
	DB	'e with name %wZ', 0aH, 00H			;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0CC@ILDFKBLG@DriverEntry?5?3?5IoAllocateMdl?5fail@PBOPGDP@
INIT$s	SEGMENT
??_C@_0CC@ILDFKBLG@DriverEntry?5?3?5IoAllocateMdl?5fail@PBOPGDP@ DB 'Driv'
	DB	'erEntry : IoAllocateMdl fails', 00H		;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0BB@OCFKBBEC@NtBuildNumber?$DN?$CFd?$AA@PBOPGDP@
INIT$s	SEGMENT
??_C@_0BB@OCFKBBEC@NtBuildNumber?$DN?$CFd?$AA@PBOPGDP@ DB 'NtBuildNumber='
	DB	'%d', 00H					;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
tv134 = -16						; size = 4
tv68 = -12						; size = 4
_status$ = -8						; size = 4
_DeviceObject$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 16   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 17   : 	NTSTATUS			status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 18   : 	PDEVICE_OBJECT		DeviceObject	= NULL;

	mov	DWORD PTR _DeviceObject$[ebp], 0

; 19   : 
; 20   : 	UNREFERENCED_PARAMETER(RegistryPath);
; 21   : 
; 22   : /*
; 23   : 1 - NtOpenProcess
; 24   : 2 - NtTerminateProcess
; 25   : 3- ...........
; 26   :  			NtBuildNumber	1			2			3			
; 27   : Windows 2000	SP0	2195	0x006a		0x00e0		...........	
; 28   : 				SP1	2195	0x006a		0x00e0		...........
; 29   : 				SP2	2195	0x006a		0x00e0		...........
; 30   : 				SP3	2195	0x006a		0x00e0		...........
; 31   : 				SP4	2195	0x006a		0x00e0		...........
; 32   : Windows XP		SP0	2600	0x007a		0x0101		...........	
; 33   : 				SP1	2600	0x007a		0x0101		...........
; 34   : 				SP2	2600	0x007a		0x0101		...........
; 35   : 				SP3	2600	0x007a		0x0101		...........
; 36   : Windows 2003	SP0	3790	0x0080		0x010a		...........	
; 37   : 	Server		SP1	3790	0x0080		0x010a		...........
; 38   : 				SP2	3790	0x0080		0x010a		...........
; 39   : Windows Vista	SP0	6000	0x00bf		0x014f		...........	
; 40   : 				SP1	6000	0x00c2		0x014e		...........	
; 41   : 				SP2	6002	0x00c2		0x014e		...........	
; 42   : Windows 2008 	SP0	6001	0x00c2		0x014e		...........	
; 43   : 	Server		SP1	6001	0x00c2		0x014e		...........
; 44   : 				SP2	6002	0x00c2		0x014e		...........	
; 45   : Windows 7		SP0	7600	0x00be		0x0172		...........
; 46   : 				SP1	7601	0x00be		0x0172		...........
; 47   : */
; 48   : 
; 49   : 	KdPrint(("NtBuildNumber=%d",(USHORT)*NtBuildNumber));

	mov	eax, DWORD PTR _NtBuildNumber
	movzx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0BB@OCFKBBEC@NtBuildNumber?$DN?$CFd?$AA@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 50   : 
; 51   : 	switch(*NtBuildNumber)

	mov	edx, DWORD PTR _NtBuildNumber
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 6001		; 00001771H
	jg	SHORT $LN17@DriverEntr
	cmp	DWORD PTR tv68[ebp], 6001		; 00001771H
	je	$LN7@DriverEntr
	cmp	DWORD PTR tv68[ebp], 3790		; 00000eceH
	jg	SHORT $LN18@DriverEntr
	cmp	DWORD PTR tv68[ebp], 3790		; 00000eceH
	je	SHORT $LN10@DriverEntr
	cmp	DWORD PTR tv68[ebp], 2195		; 00000893H
	je	SHORT $LN12@DriverEntr
	cmp	DWORD PTR tv68[ebp], 2600		; 00000a28H
	je	SHORT $LN11@DriverEntr
	jmp	$LN4@DriverEntr
$LN18@DriverEntr:
	cmp	DWORD PTR tv68[ebp], 6000		; 00001770H
	je	SHORT $LN9@DriverEntr
	jmp	$LN4@DriverEntr
$LN17@DriverEntr:
	cmp	DWORD PTR tv68[ebp], 6002		; 00001772H
	je	SHORT $LN8@DriverEntr
	cmp	DWORD PTR tv68[ebp], 7600		; 00001db0H
	je	$LN6@DriverEntr
	cmp	DWORD PTR tv68[ebp], 7601		; 00001db1H
	je	$LN5@DriverEntr
	jmp	$LN4@DriverEntr
$LN12@DriverEntr:

; 52   : 	{
; 53   : 		case 2195:
; 54   : 			gZwOpenProcessNumber		= 0x006a;

	mov	DWORD PTR _gZwOpenProcessNumber, 106	; 0000006aH

; 55   : 			gZwTerminateProcessNumber	= 0x00e0;

	mov	DWORD PTR _gZwTerminateProcessNumber, 224 ; 000000e0H

; 56   : 			break;

	jmp	$LN13@DriverEntr
$LN11@DriverEntr:

; 57   : 		case 2600:
; 58   : 			gZwOpenProcessNumber		= 0x007a;

	mov	DWORD PTR _gZwOpenProcessNumber, 122	; 0000007aH

; 59   : 			gZwTerminateProcessNumber	= 0x0101;

	mov	DWORD PTR _gZwTerminateProcessNumber, 257 ; 00000101H

; 60   : 			break;

	jmp	$LN13@DriverEntr
$LN10@DriverEntr:

; 61   : 		case 3790:
; 62   : 			gZwOpenProcessNumber		= 0x0080;

	mov	DWORD PTR _gZwOpenProcessNumber, 128	; 00000080H

; 63   : 			gZwTerminateProcessNumber	= 0x010a;

	mov	DWORD PTR _gZwTerminateProcessNumber, 266 ; 0000010aH

; 64   : 			break;

	jmp	SHORT $LN13@DriverEntr
$LN9@DriverEntr:

; 65   : 		case 6000:
; 66   : 			gZwOpenProcessNumber		= 0x00bf;

	mov	DWORD PTR _gZwOpenProcessNumber, 191	; 000000bfH

; 67   : 			gZwTerminateProcessNumber	= 0x014f;

	mov	DWORD PTR _gZwTerminateProcessNumber, 335 ; 0000014fH

; 68   : 			break;

	jmp	SHORT $LN13@DriverEntr
$LN8@DriverEntr:

; 69   : 		case 6002:
; 70   : 			gZwOpenProcessNumber		= 0x00c2;

	mov	DWORD PTR _gZwOpenProcessNumber, 194	; 000000c2H

; 71   : 			gZwTerminateProcessNumber	= 0x014e;

	mov	DWORD PTR _gZwTerminateProcessNumber, 334 ; 0000014eH

; 72   : 			break;

	jmp	SHORT $LN13@DriverEntr
$LN7@DriverEntr:

; 73   : 		case 6001:
; 74   : 			gZwOpenProcessNumber		= 0x00c2;

	mov	DWORD PTR _gZwOpenProcessNumber, 194	; 000000c2H

; 75   : 			gZwTerminateProcessNumber	= 0x014e;

	mov	DWORD PTR _gZwTerminateProcessNumber, 334 ; 0000014eH

; 76   : 			break;

	jmp	SHORT $LN13@DriverEntr
$LN6@DriverEntr:

; 77   : 		case 7600:
; 78   : 			gZwOpenProcessNumber		= 0x00be;

	mov	DWORD PTR _gZwOpenProcessNumber, 190	; 000000beH

; 79   : 			gZwTerminateProcessNumber	= 0x0172;

	mov	DWORD PTR _gZwTerminateProcessNumber, 370 ; 00000172H

; 80   : 			break;

	jmp	SHORT $LN13@DriverEntr
$LN5@DriverEntr:

; 81   : 		case 7601:
; 82   : 			gZwOpenProcessNumber		= 0x00be;

	mov	DWORD PTR _gZwOpenProcessNumber, 190	; 000000beH

; 83   : 			gZwTerminateProcessNumber	= 0x0172;

	mov	DWORD PTR _gZwTerminateProcessNumber, 370 ; 00000172H

; 84   : 			break;

	jmp	SHORT $LN13@DriverEntr
$LN4@DriverEntr:

; 85   : 		default:
; 86   : 			return STATUS_DEVICE_CONFIGURATION_ERROR;

	mov	eax, -1073741438			; c0000182H
	jmp	$LN15@DriverEntr
$LN13@DriverEntr:

; 87   : 			break; 
; 88   : 	}
; 89   : 
; 90   : 	gSSTMdl	= IoAllocateMdl(	KeServiceDescriptorTable->ntoskrnl.ServiceTable,
; 91   : 							KeServiceDescriptorTable->ntoskrnl.ServiceLimit*sizeof(PVOID),
; 92   : 							FALSE, FALSE, NULL	);	

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _KeServiceDescriptorTable
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _KeServiceDescriptorTable
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__IoAllocateMdl@20
	mov	DWORD PTR _gSSTMdl, eax

; 93   : 
; 94   : 	if( !gSSTMdl)

	cmp	DWORD PTR _gSSTMdl, 0
	jne	SHORT $LN3@DriverEntr

; 95   : 	{
; 96   : 		KdPrint((__FUNCTION__" : IoAllocateMdl fails"));

	push	OFFSET ??_C@_0CC@ILDFKBLG@DriverEntry?5?3?5IoAllocateMdl?5fail@PBOPGDP@
	call	_DbgPrint
	add	esp, 4

; 97   : 		return STATUS_INSUFFICIENT_RESOURCES;

	mov	eax, -1073741670			; c000009aH
	jmp	$LN15@DriverEntr
$LN3@DriverEntr:

; 98   : 	}	
; 99   : 	
; 100  : 	 MmBuildMdlForNonPagedPool(gSSTMdl);

	mov	edx, DWORD PTR _gSSTMdl
	push	edx
	call	DWORD PTR __imp__MmBuildMdlForNonPagedPool@4

; 101  : 	gSSTAddr = MmGetSystemAddressForMdlSafe(gSSTMdl, NormalPagePriority);

	mov	eax, DWORD PTR _gSSTMdl
	movsx	ecx, WORD PTR [eax+6]
	and	ecx, 5
	je	SHORT $LN19@DriverEntr
	mov	edx, DWORD PTR _gSSTMdl
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN20@DriverEntr
$LN19@DriverEntr:
	push	16					; 00000010H
	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _gSSTMdl
	push	ecx
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv134[ebp], eax
$LN20@DriverEntr:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _gSSTAddr, edx

; 102  : 	
; 103  : 	status = IoCreateDevice(DriverObject,
; 104  : 						NULL,
; 105  : 						(PUNICODE_STRING)&deviceName,
; 106  : 						DEV_TYPE, FILE_DEVICE_SECURE_OPEN,
; 107  : 						FALSE, &DeviceObject);                        

	lea	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	push	34					; 00000022H
	push	OFFSET _deviceName
	push	0
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 108  : 
; 109  : 	if( !NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@DriverEntr

; 110  : 	{
; 111  : 		KdPrint((__FUNCTION__" : IoCreateDevice fails with status = 0x%08X for device with name %wZ\n", 
; 112  : 					status, (PUNICODE_STRING)&deviceName) );

	push	OFFSET _deviceName
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 113  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN15@DriverEntr
$LN2@DriverEntr:

; 114  : 	}
; 115  : 	
; 116  : 	status = IoCreateSymbolicLink(	(PUNICODE_STRING)&symbolicLinkName, 
; 117  : 								(PUNICODE_STRING)&deviceName	);

	push	OFFSET _deviceName
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 118  : 		
; 119  : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@DriverEntr

; 120  : 	{
; 121  : 		KdPrint((__FUNCTION__" : IoCreateSymbolicLink fails with status = 0x%08X\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 122  : 		IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 123  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN15@DriverEntr
$LN1@DriverEntr:

; 124  : 	}
; 125  : 
; 126  : 	DriverObject->MajorFunction[IRP_MJ_CREATE]			=  
; 127  : 	DriverObject->MajorFunction[IRP_MJ_CLOSE]				= CreateCloseDispatchRoutine;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+64], OFFSET _CreateCloseDispatchRoutine@8
	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+56], edx

; 128  : 	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]	= DeviceControlDispatchRoutine;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+112], OFFSET _DeviceControlDispatchRoutine@8

; 129  : 	DriverObject->DriverUnload								= DriverUnload;

	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [ecx+52], OFFSET _DriverUnload@4

; 130  : 	gActive	= FALSE;

	mov	BYTE PTR _gActive, 0

; 131  : 
; 132  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN15@DriverEntr:

; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
INIT	ENDS
PUBLIC	??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EP@NELPDCOK@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__RtlAssert@16:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
;	COMDAT ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@ DB 'Irp', 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_01GBGANLPD@0?$AA@NNGAKEGL@ DB '0', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EP@NELPDCOK@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EP@NELPDCOK@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ DB 'c:'
	DB	'\radasm\wdk\projects\driver_projects\pdlr09_gladyr\selfdefenc'
	DB	'e\selfdefence.c', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ DB 'E'
	DB	'X: Pageable code called at IRQL %d', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _CreateCloseDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CreateCloseDispatchRoutine@8 PROC			; COMDAT

; 138  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 139  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 140  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CreateClos
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	140					; 0000008cH
	push	OFFSET ??_C@_0EP@NELPDCOK@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CreateClos:

; 141  : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CreateClos
	push	0
	push	141					; 0000008dH
	push	OFFSET ??_C@_0EP@NELPDCOK@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CreateClos
$LN4@CreateClos:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CreateClos:

; 142  : 
; 143  : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 144  : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 145  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 146  : 	return STATUS_SUCCESS;

	xor	eax, eax

; 147  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateCloseDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CL@ECCFJMA@DeviceControlDispatchRoutine?5?3?5N@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_NewZwTerminateProcess@8
PUBLIC	_NewZwOpenProcess@16
PUBLIC	??_C@_0DB@KAKKGENO@DeviceControlDispatchRoutine?5?3?5S@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CP@JGPPFMKG@DeviceControlDispatchRoutine?5?3?5A@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EB@LFEEEOND@DeviceControlDispatchRoutine?5?3?5I@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	__imp__PsGetCurrentProcessId@0:PROC
;	COMDAT ??_C@_0CL@ECCFJMA@DeviceControlDispatchRoutine?5?3?5N@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CL@ECCFJMA@DeviceControlDispatchRoutine?5?3?5N@NNGAKEGL@ DB 'Devic'
	DB	'eControlDispatchRoutine : Not active', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DB@KAKKGENO@DeviceControlDispatchRoutine?5?3?5S@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DB@KAKKGENO@DeviceControlDispatchRoutine?5?3?5S@NNGAKEGL@ DB 'Devi'
	DB	'ceControlDispatchRoutine : Stranger process', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CP@JGPPFMKG@DeviceControlDispatchRoutine?5?3?5A@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CP@JGPPFMKG@DeviceControlDispatchRoutine?5?3?5A@NNGAKEGL@ DB 'Devi'
	DB	'ceControlDispatchRoutine : Already active', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EB@LFEEEOND@DeviceControlDispatchRoutine?5?3?5I@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EB@LFEEEOND@DeviceControlDispatchRoutine?5?3?5I@NNGAKEGL@ DB 'Devi'
	DB	'ceControlDispatchRoutine : Input buffer length = %d invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _DeviceControlDispatchRoutine@8
PAGE	SEGMENT
tv81 = -24						; size = 4
_status$ = -20						; size = 4
_ioStack$ = -16						; size = 4
_inBufLen$ = -12					; size = 4
_inBuf$ = -8						; size = 4
_RegCr0$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DeviceControlDispatchRoutine@8 PROC			; COMDAT

; 152  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 153  : 	NTSTATUS				status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 154  : 	PIO_STACK_LOCATION		ioStack		= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 155  : 	ULONG					inBufLen		= ioStack->Parameters.DeviceIoControl.InputBufferLength;

	mov	ecx, DWORD PTR _ioStack$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _inBufLen$[ebp], edx

; 156  : 	PHANDLE               			inBuf		= Irp->AssociatedIrp.SystemBuffer;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _inBuf$[ebp], ecx

; 157  : 	ULONG					RegCr0		= 0;

	mov	DWORD PTR _RegCr0$[ebp], 0

; 158  : 
; 159  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	cmp	edx, 1
	jle	SHORT $LN12@DeviceCont
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	159					; 0000009fH
	push	OFFSET ??_C@_0EP@NELPDCOK@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN12@DeviceCont:

; 160  : 	
; 161  : 	Irp->IoStatus.Information = 0;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 162  : 	switch(ioStack->Parameters.DeviceIoControl.IoControlCode)

	mov	edx, DWORD PTR _ioStack$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 2236416		; 00222000H
	je	SHORT $LN9@DeviceCont
	cmp	DWORD PTR tv81[ebp], 2236420		; 00222004H
	je	$LN5@DeviceCont
	jmp	$LN1@DeviceCont
$LN9@DeviceCont:

; 163  : 	{
; 164  : 		case IOCTL_PROCESS_LOCK:
; 165  : 		
; 166  : 			if( inBufLen != sizeof(HANDLE) )

	cmp	DWORD PTR _inBufLen$[ebp], 4
	je	SHORT $LN8@DeviceCont

; 167  : 			{
; 168  : 				KdPrint( (__FUNCTION__" : Input buffer length = %d invalid\n", inBufLen) );

	mov	ecx, DWORD PTR _inBufLen$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EB@LFEEEOND@DeviceControlDispatchRoutine?5?3?5I@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 169  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 170  : 				break;

	jmp	$LN10@DeviceCont
$LN8@DeviceCont:

; 171  : 			}
; 172  : 			
; 173  : 			if ( gActive )

	movzx	edx, BYTE PTR _gActive
	test	edx, edx
	je	SHORT $LN7@DeviceCont

; 174  : 			{
; 175  : 				KdPrint( (__FUNCTION__" : Already active\n") );

	push	OFFSET ??_C@_0CP@JGPPFMKG@DeviceControlDispatchRoutine?5?3?5A@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 176  : 				break;

	jmp	$LN10@DeviceCont
$LN7@DeviceCont:

; 177  : 			}
; 178  : 
; 179  : 			 if(PsGetCurrentProcessId() != *inBuf)

	call	DWORD PTR __imp__PsGetCurrentProcessId@0
	mov	ecx, DWORD PTR _inBuf$[ebp]
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN6@DeviceCont

; 180  : 			 {
; 181  : 				KdPrint( (__FUNCTION__" : Stranger process\n") );

	push	OFFSET ??_C@_0DB@KAKKGENO@DeviceControlDispatchRoutine?5?3?5S@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 182  : 				status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H

; 183  : 				break;

	jmp	$LN10@DeviceCont
$LN6@DeviceCont:

; 184  : 			 }
; 185  : 			  
; 186  : 			gOwnerPID = *inBuf;

	mov	edx, DWORD PTR _inBuf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _gOwnerPID, eax

; 187  :  		 	
; 188  :    		 	gRealZwOpenProcess = InterlockedExchangePointer(
; 189  :  		 			&gSSTAddr[gZwOpenProcessNumber],
; 190  :  		 			NewZwOpenProcess);

	mov	ecx, OFFSET _NewZwOpenProcess@16
	mov	edx, DWORD PTR _gZwOpenProcessNumber
	mov	eax, DWORD PTR _gSSTAddr
	lea	edx, DWORD PTR [eax+edx*4]
	xchg	DWORD PTR [edx], ecx
	mov	DWORD PTR _gRealZwOpenProcess, ecx

; 191  : 
; 192  :  		 	gRealZwTerminateProcess = InterlockedExchangePointer(
; 193  :  		 			&gSSTAddr[gZwTerminateProcessNumber],
; 194  :  		 			NewZwTerminateProcess);

	mov	eax, OFFSET _NewZwTerminateProcess@8
	mov	ecx, DWORD PTR _gZwTerminateProcessNumber
	mov	edx, DWORD PTR _gSSTAddr
	lea	ecx, DWORD PTR [edx+ecx*4]
	xchg	DWORD PTR [ecx], eax
	mov	DWORD PTR _gRealZwTerminateProcess, eax

; 195  :  			
; 196  :  			gActive = TRUE;

	mov	BYTE PTR _gActive, 1

; 197  : 			break;

	jmp	$LN10@DeviceCont
$LN5@DeviceCont:

; 198  : 		case IOCTL_PROCESS_UNLOCK:
; 199  : 			if( inBufLen != sizeof(HANDLE) )

	cmp	DWORD PTR _inBufLen$[ebp], 4
	je	SHORT $LN4@DeviceCont

; 200  : 			{
; 201  : 				KdPrint( (__FUNCTION__" : Input buffer length = %d invalid\n", inBufLen) );

	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	push	OFFSET ??_C@_0EB@LFEEEOND@DeviceControlDispatchRoutine?5?3?5I@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 202  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 203  : 				break;

	jmp	$LN10@DeviceCont
$LN4@DeviceCont:

; 204  : 			}
; 205  : 			
; 206  : 			if ( !gActive )

	movzx	eax, BYTE PTR _gActive
	test	eax, eax
	jne	SHORT $LN3@DeviceCont

; 207  : 			{
; 208  : 				KdPrint( (__FUNCTION__" : Not active\n") );

	push	OFFSET ??_C@_0CL@ECCFJMA@DeviceControlDispatchRoutine?5?3?5N@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 209  : 				break;

	jmp	SHORT $LN10@DeviceCont
$LN3@DeviceCont:

; 210  : 			}
; 211  : 
; 212  : 			 if(PsGetCurrentProcessId() != *inBuf)

	call	DWORD PTR __imp__PsGetCurrentProcessId@0
	mov	ecx, DWORD PTR _inBuf$[ebp]
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN2@DeviceCont

; 213  : 			 {
; 214  : 				KdPrint( (__FUNCTION__" : Stranger process\n") );

	push	OFFSET ??_C@_0DB@KAKKGENO@DeviceControlDispatchRoutine?5?3?5S@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 215  : 				status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H

; 216  : 				break;

	jmp	SHORT $LN10@DeviceCont
$LN2@DeviceCont:

; 217  : 			 } 
; 218  : 
; 219  :   		 	InterlockedExchangePointer(
; 220  :  		 			&gSSTAddr[gZwOpenProcessNumber],
; 221  :  		 			gRealZwOpenProcess);

	mov	edx, DWORD PTR _gRealZwOpenProcess
	mov	eax, DWORD PTR _gZwOpenProcessNumber
	mov	ecx, DWORD PTR _gSSTAddr
	lea	eax, DWORD PTR [ecx+eax*4]
	xchg	DWORD PTR [eax], edx

; 222  : 
; 223  :  		 	InterlockedExchangePointer(
; 224  :  		 			&gSSTAddr[gZwTerminateProcessNumber],
; 225  :  		 			gRealZwTerminateProcess);

	mov	ecx, DWORD PTR _gRealZwTerminateProcess
	mov	edx, DWORD PTR _gZwTerminateProcessNumber
	mov	eax, DWORD PTR _gSSTAddr
	lea	edx, DWORD PTR [eax+edx*4]
	xchg	DWORD PTR [edx], ecx

; 226  : 		
; 227  :  			gActive = FALSE;

	mov	BYTE PTR _gActive, 0

; 228  :  			gOwnerPID = NULL;

	mov	DWORD PTR _gOwnerPID, 0

; 229  : 			break;		

	jmp	SHORT $LN10@DeviceCont
$LN1@DeviceCont:

; 230  : 		default:
; 231  : 			status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H
$LN10@DeviceCont:

; 232  : 			break;
; 233  : 	}	
; 234  : 		
; 235  : 	Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 236  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 237  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DeviceControlDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ DB 'c:\win'
	DB	'ddk\inc\ddk\wdm.h', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	push	0
	push	23317					; 00005b15H
	push	OFFSET ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
	push	OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 23319: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
EXTRN	__imp__IoFreeMdl@4:PROC
; Function compile flags: /Odtp
; File c:\radasm\wdk\projects\driver_projects\pdlr09_gladyr\selfdefence\selfdefence.c
;	COMDAT _DriverUnload@4
PAGE	SEGMENT
_DeviceObject$ = -8					; size = 4
_RegCr0$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_DriverUnload@4 PROC					; COMDAT

; 242  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 243  : 	PDEVICE_OBJECT		DeviceObject	= DriverObject->DeviceObject;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _DeviceObject$[ebp], ecx

; 244  : 	ULONG				RegCr0		= 0;

	mov	DWORD PTR _RegCr0$[ebp], 0

; 245  : 	
; 246  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	cmp	edx, 1
	jle	SHORT $LN3@DriverUnlo
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	246					; 000000f6H
	push	OFFSET ??_C@_0EP@NELPDCOK@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN3@DriverUnlo:

; 247  : 	
; 248  : 	if ( gActive )

	movzx	ecx, BYTE PTR _gActive
	test	ecx, ecx
	je	SHORT $LN2@DriverUnlo

; 249  : 	{
; 250  : 	 	InterlockedExchangePointer(
; 251  : 	 			&gSSTAddr[gZwOpenProcessNumber],
; 252  : 	 			gRealZwOpenProcess);

	mov	edx, DWORD PTR _gRealZwOpenProcess
	mov	eax, DWORD PTR _gZwOpenProcessNumber
	mov	ecx, DWORD PTR _gSSTAddr
	lea	eax, DWORD PTR [ecx+eax*4]
	xchg	DWORD PTR [eax], edx

; 253  : 
; 254  : 	 	InterlockedExchangePointer(
; 255  : 	 			&gSSTAddr[gZwTerminateProcessNumber],
; 256  : 	 			gRealZwTerminateProcess);

	mov	ecx, DWORD PTR _gRealZwTerminateProcess
	mov	edx, DWORD PTR _gZwTerminateProcessNumber
	mov	eax, DWORD PTR _gSSTAddr
	lea	edx, DWORD PTR [eax+edx*4]
	xchg	DWORD PTR [edx], ecx
$LN2@DriverUnlo:

; 257  : 	}
; 258  : 	
; 259  : 	if( !gSSTMdl )

	cmp	DWORD PTR _gSSTMdl, 0
	jne	SHORT $LN1@DriverUnlo

; 260  : 		IoFreeMdl(gSSTMdl);

	mov	eax, DWORD PTR _gSSTMdl
	push	eax
	call	DWORD PTR __imp__IoFreeMdl@4
$LN1@DriverUnlo:

; 261  : 				
; 262  : 	IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 263  : 	IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 264  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DriverUnload@4 ENDP
; Function compile flags: /Odtp
PAGE	ENDS
;	COMDAT _NewZwOpenProcess@16
_TEXT	SEGMENT
_ProcessHandle$ = 8					; size = 4
_DesiredAccess$ = 12					; size = 4
_ObjectAttributes$ = 16					; size = 4
_ClientId$ = 20						; size = 4
_NewZwOpenProcess@16 PROC				; COMDAT

; 272  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 273  : 	if(ClientId)

	cmp	DWORD PTR _ClientId$[ebp], 0
	je	SHORT $LN2@NewZwOpenP

; 274  : 	{
; 275  : 		if(ClientId->UniqueProcess == gOwnerPID)

	mov	eax, DWORD PTR _ClientId$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _gOwnerPID
	jne	SHORT $LN2@NewZwOpenP

; 276  : /*
; 277  : HANDLE WINAPI OpenProcess(	__in          DWORD dwDesiredAccess, 
; 278  : 							__in          BOOL bInheritHandle, 
; 279  : 							__in          DWORD dwProcessId	);
; 280  : 
; 281  : dwDesiredAccess :		
; 282  : PROCESS_TERMINATE (0x0001)			-  TerminateProcess
; 283  : PROCESS_CREATE_THREAD (0x0002)	- CreateRemoteThread 
; 284  : PROCESS_VM_OPERATION (0x0008)		- VirtualProtectEx/WriteProcessMemory
; 285  : PROCESS_SET_INFORMATION (0x0200)	- SetPriorityClass
; 286  : PROCESS_SUSPEND_RESUME (0x800)	- SuspendThread i ResumeThread
; 287  : */ 		
; 288  : 		DesiredAccess &= ~( 0x0001 |0x0002|0x0008|0x0200|0x800 );	

	mov	edx, DWORD PTR _DesiredAccess$[ebp]
	and	edx, -2572				; fffff5f4H
	mov	DWORD PTR _DesiredAccess$[ebp], edx
$LN2@NewZwOpenP:

; 289  : 	}
; 290  : 	return gRealZwOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);	

	mov	eax, DWORD PTR _ClientId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ObjectAttributes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DesiredAccess$[ebp]
	push	edx
	mov	eax, DWORD PTR _ProcessHandle$[ebp]
	push	eax
	call	DWORD PTR _gRealZwOpenProcess

; 291  : }

	pop	ebp
	ret	16					; 00000010H
_NewZwOpenProcess@16 ENDP
_TEXT	ENDS
EXTRN	__imp__ZwQueryInformationProcess@20:PROC
; Function compile flags: /Odtp
;	COMDAT _NewZwTerminateProcess@8
_TEXT	SEGMENT
_processId$ = -32					; size = 4
_status$ = -28						; size = 4
_processInfo$ = -24					; size = 24
_ProcessHandle$ = 8					; size = 4
_ExitStatus$ = 12					; size = 4
_NewZwTerminateProcess@8 PROC				; COMDAT

; 297  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 298  : 	PROCESS_BASIC_INFORMATION	processInfo	= {0};

	mov	DWORD PTR _processInfo$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _processInfo$[ebp+4], eax
	mov	DWORD PTR _processInfo$[ebp+8], eax
	mov	DWORD PTR _processInfo$[ebp+12], eax
	mov	DWORD PTR _processInfo$[ebp+16], eax
	mov	DWORD PTR _processInfo$[ebp+20], eax

; 299  : 	NTSTATUS						status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 300  : 	HANDLE							processId	= 0;	

	mov	DWORD PTR _processId$[ebp], 0

; 301  : 	
; 302  : 	if( (HANDLE)0 != ProcessHandle && (HANDLE)-1 !=ProcessHandle )

	cmp	DWORD PTR _ProcessHandle$[ebp], 0
	je	SHORT $LN3@NewZwTermi
	cmp	DWORD PTR _ProcessHandle$[ebp], -1
	je	SHORT $LN3@NewZwTermi

; 303  : 	{
; 304  : 		status = ZwQueryInformationProcess(
; 305  : 							ProcessHandle, 
; 306  : 							ProcessBasicInformation, 
; 307  : 							&processInfo,
; 308  : 							sizeof(PROCESS_BASIC_INFORMATION), 
; 309  : 							NULL);

	push	0
	push	24					; 00000018H
	lea	ecx, DWORD PTR _processInfo$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ProcessHandle$[ebp]
	push	edx
	call	DWORD PTR __imp__ZwQueryInformationProcess@20
	mov	DWORD PTR _status$[ebp], eax

; 310  : 		if ( NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN3@NewZwTermi

; 311  : 		{
; 312  : 			if( processInfo.UniqueProcessId == (ULONG_PTR)gOwnerPID )

	mov	eax, DWORD PTR _processInfo$[ebp+16]
	cmp	eax, DWORD PTR _gOwnerPID
	jne	SHORT $LN3@NewZwTermi

; 313  : 				return STATUS_ACCESS_DENIED;

	mov	eax, -1073741790			; c0000022H
	jmp	SHORT $LN4@NewZwTermi
$LN3@NewZwTermi:

; 314  : 		}		
; 315  : 	}
; 316  : 	return gRealZwTerminateProcess(ProcessHandle, ExitStatus);	

	mov	ecx, DWORD PTR _ExitStatus$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ProcessHandle$[ebp]
	push	edx
	call	DWORD PTR _gRealZwTerminateProcess
$LN4@NewZwTermi:

; 317  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_NewZwTerminateProcess@8 ENDP
_TEXT	ENDS
END
