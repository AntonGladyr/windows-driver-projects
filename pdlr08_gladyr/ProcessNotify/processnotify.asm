; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr08_gladyr\processnotify\processnotify.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deviceName_buffer
PUBLIC	_deviceName
PUBLIC	_symbolicLinkName_buffer
PUBLIC	_symbolicLinkName
_BSS	SEGMENT
_gNotifyState DB 01H DUP (?)
	ALIGN	4

_gEventSendData DD 01H DUP (?)
_gEventImageSendData DD 01H DUP (?)
_gMutex	DB	020H DUP (?)
_gImageMutex DB	020H DUP (?)
_gProcessNotifyInfo DB 0cH DUP (?)
_gProcessImageNotifyInfo DB 020008H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_deviceName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'i'
	DB	00H, 'f', 00H, 'y', 00H, 00H, 00H
_deviceName DW	02aH
	DW	02cH
	DD	FLAT:_deviceName_buffer
_symbolicLinkName_buffer DB '\', 00H, '?', 00H, '?', 00H, '\', 00H, 'P', 00H
	DB	'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'N'
	DB	00H, 'o', 00H, 't', 00H, 'i', 00H, 'f', 00H, 'y', 00H, 00H, 00H
_symbolicLinkName DW 022H
	DW	024H
	DD	FLAT:_symbolicLinkName_buffer
CONST	ENDS
PUBLIC	_ProcessNotifyRoutine@12
EXTRN	__imp__KeReleaseMutex@8:PROC
EXTRN	__imp__KeSetEvent@12:PROC
EXTRN	__imp__KeWaitForSingleObject@20:PROC
; Function compile flags: /Odtp
; File c:\radasm\wdk\projects\driver_projects\pdlr08_gladyr\processnotify\processnotify.c
;	COMDAT _ProcessNotifyRoutine@12
_TEXT	SEGMENT
_parentId$ = 8						; size = 4
_processId$ = 12					; size = 4
_isCreate$ = 16						; size = 1
_ProcessNotifyRoutine@12 PROC				; COMDAT

; 15   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 16   : 	KeWaitForSingleObject(&gMutex, UserRequest, KernelMode, TRUE, NULL);

	push	0
	push	1
	push	0
	push	6
	push	OFFSET _gMutex
	call	DWORD PTR __imp__KeWaitForSingleObject@20

; 17   : 	gProcessNotifyInfo.ParentId	= parentId;

	mov	eax, DWORD PTR _parentId$[ebp]
	mov	DWORD PTR _gProcessNotifyInfo, eax

; 18   : 	gProcessNotifyInfo.ProcessId	= processId;

	mov	ecx, DWORD PTR _processId$[ebp]
	mov	DWORD PTR _gProcessNotifyInfo+4, ecx

; 19   : 	gProcessNotifyInfo.Create		= isCreate;

	mov	dl, BYTE PTR _isCreate$[ebp]
	mov	BYTE PTR _gProcessNotifyInfo+8, dl

; 20   : 	KeSetEvent(gEventSendData, IO_NO_INCREMENT, FALSE);

	push	0
	push	0
	mov	eax, DWORD PTR _gEventSendData
	push	eax
	call	DWORD PTR __imp__KeSetEvent@12

; 21   : 	KeReleaseMutex(&gMutex, FALSE);

	push	0
	push	OFFSET _gMutex
	call	DWORD PTR __imp__KeReleaseMutex@8

; 22   : 	return;	
; 23   : }

	pop	ebp
	ret	12					; 0000000cH
_ProcessNotifyRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_ImageNotifyRoutine@12
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT _ImageNotifyRoutine@12
_TEXT	SEGMENT
_fullImageName$ = 8					; size = 4
_processId$ = 12					; size = 4
_imageInfo$ = 16					; size = 4
_ImageNotifyRoutine@12 PROC				; COMDAT

; 28   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 29   : 	KeWaitForSingleObject(&gImageMutex, UserRequest, KernelMode, TRUE, NULL);

	push	0
	push	1
	push	0
	push	6
	push	OFFSET _gImageMutex
	call	DWORD PTR __imp__KeWaitForSingleObject@20

; 30   : 	memcpy(gProcessImageNotifyInfo.FullImageName, fullImageName->Buffer, fullImageName->Length );

	mov	eax, DWORD PTR _fullImageName$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _fullImageName$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET _gProcessImageNotifyInfo+4
	call	_memcpy
	add	esp, 12					; 0000000cH

; 31   : 	gProcessImageNotifyInfo.ImageSize = imageInfo->ImageSize;

	mov	ecx, DWORD PTR _imageInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _gProcessImageNotifyInfo+131076, edx

; 32   : 	gProcessImageNotifyInfo.ImageBase = imageInfo->ImageBase;

	mov	eax, DWORD PTR _imageInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _gProcessImageNotifyInfo, ecx

; 33   : 	KeSetEvent(gEventImageSendData, IO_NO_INCREMENT, FALSE);

	push	0
	push	0
	mov	edx, DWORD PTR _gEventImageSendData
	push	edx
	call	DWORD PTR __imp__KeSetEvent@12

; 34   : 	KeReleaseMutex(&gImageMutex, FALSE);

	push	0
	push	OFFSET _gImageMutex
	call	DWORD PTR __imp__KeReleaseMutex@8

; 35   : 	return;
; 36   : }

	pop	ebp
	ret	12					; 0000000cH
_ImageNotifyRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_DeviceControlDispatchRoutine@8
PUBLIC	_CreateCloseDispatchRoutine@8
PUBLIC	??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	_DriverEntry@8
EXTRN	__imp__KeInitializeMutex@8:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
;	COMDAT ??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@
INIT$s	SEGMENT
??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@ DB 'DriverE'
	DB	'ntry:IoCreateSymbolicLink fails with status = 0x%08X', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@
INIT$s	SEGMENT
??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@ DB 'Driver'
	DB	'Entry:IoCreateDevice fails with status = 0x%08X for device wi'
	DB	'th name %wZ', 0aH, 00H			;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_status$ = -8						; size = 4
_DeviceObject$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 41   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 42   : 	NTSTATUS		status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 43   : 	PDEVICE_OBJECT	DeviceObject	= NULL;

	mov	DWORD PTR _DeviceObject$[ebp], 0

; 44   : 
; 45   : 	UNREFERENCED_PARAMETER(RegistryPath);
; 46   : 
; 47   : 	status = IoCreateDevice(	DriverObject,
; 48   : 							0,
; 49   : 							(PUNICODE_STRING)&deviceName,
; 50   : 							DEV_TYPE, FILE_DEVICE_SECURE_OPEN,
; 51   : 							FALSE, &DeviceObject);                        

	lea	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	push	34					; 00000022H
	push	OFFSET _deviceName
	push	0
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 52   : 	
; 53   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@DriverEntr

; 54   : 	{
; 55   : 		KdPrint((__FUNCTION__":IoCreateDevice fails with status = 0x%08X for device with name %wZ\n", 
; 56   : 					status, (PUNICODE_STRING)&deviceName) );

	push	OFFSET _deviceName
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 57   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN3@DriverEntr
$LN2@DriverEntr:

; 58   : 	}
; 59   : 	
; 60   : 	status = IoCreateSymbolicLink(	(PUNICODE_STRING)&symbolicLinkName, 
; 61   : 									(PUNICODE_STRING)&deviceName	);

	push	OFFSET _deviceName
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 62   : 		
; 63   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@DriverEntr

; 64   : 	{
; 65   : 		KdPrint((__FUNCTION__":IoCreateSymbolicLink fails with status = 0x%08X\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 66   : 		IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 67   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN3@DriverEntr
$LN1@DriverEntr:

; 68   : 	}
; 69   : 	KeInitializeMutex(&gMutex, 0);

	push	0
	push	OFFSET _gMutex
	call	DWORD PTR __imp__KeInitializeMutex@8

; 70   : 	KeInitializeMutex(&gImageMutex, 0);

	push	0
	push	OFFSET _gImageMutex
	call	DWORD PTR __imp__KeInitializeMutex@8

; 71   : 	DriverObject->MajorFunction[IRP_MJ_CREATE]			= CreateCloseDispatchRoutine; 

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+56], OFFSET _CreateCloseDispatchRoutine@8

; 72   : 	DriverObject->MajorFunction[IRP_MJ_CLOSE]				= CreateCloseDispatchRoutine;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+64], OFFSET _CreateCloseDispatchRoutine@8

; 73   : 	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]	= DeviceControlDispatchRoutine;

	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [ecx+112], OFFSET _DeviceControlDispatchRoutine@8

; 74   : 	DriverObject->DriverUnload								= DriverUnload;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+52], OFFSET _DriverUnload@4

; 75   : 
; 76   : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN3@DriverEntr:

; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
INIT	ENDS
PUBLIC	??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FD@GHCNPOAM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__RtlAssert@16:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
;	COMDAT ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@ DB 'Irp', 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_01GBGANLPD@0?$AA@NNGAKEGL@ DB '0', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FD@GHCNPOAM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FD@GHCNPOAM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ DB 'c:'
	DB	'\radasm\wdk\projects\driver_projects\pdlr08_gladyr\processnot'
	DB	'ify\processnotify.c', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ DB 'E'
	DB	'X: Pageable code called at IRQL %d', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _CreateCloseDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CreateCloseDispatchRoutine@8 PROC			; COMDAT

; 82   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 83   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 84   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CreateClos
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	84					; 00000054H
	push	OFFSET ??_C@_0FD@GHCNPOAM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CreateClos:

; 85   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CreateClos
	push	0
	push	85					; 00000055H
	push	OFFSET ??_C@_0FD@GHCNPOAM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CreateClos
$LN4@CreateClos:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CreateClos:

; 86   : 
; 87   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 88   : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 89   : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 90   : 	return STATUS_SUCCESS;

	xor	eax, eax

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateCloseDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0DO@NBIAJJFI@DeviceControlDispatchRoutine?3Out@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FJ@LHIJELAB@DeviceControlDispatchRoutine?3PsR@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FG@EHIMODJA@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FK@LLOCDNCM@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FE@FMHNHJMB@DeviceControlDispatchRoutine?3ObR@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DE@EIMOCCFE@DeviceControlDispatchRoutine?3IOC@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	__imp__PsRemoveLoadImageNotifyRoutine@4:PROC
EXTRN	__imp__PsSetLoadImageNotifyRoutine@4:PROC
EXTRN	__imp__PsSetCreateProcessNotifyRoutine@8:PROC
EXTRN	__imp_@ObfDereferenceObject@4:PROC
EXTRN	__imp__ObReferenceObjectByHandle@24:PROC
EXTRN	_ExEventObjectType:DWORD
;	COMDAT ??_C@_0DO@NBIAJJFI@DeviceControlDispatchRoutine?3Out@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DO@NBIAJJFI@DeviceControlDispatchRoutine?3Out@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:Output buffer length = %d small', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FJ@LHIJELAB@DeviceControlDispatchRoutine?3PsR@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FJ@LHIJELAB@DeviceControlDispatchRoutine?3PsR@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:PsRemoveLoadImageNotifyRoutine  fails '
	DB	'with status = 0x%08X', 0aH, 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FG@EHIMODJA@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FG@EHIMODJA@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:PsSetLoadImageNotifyRoutine  fails wit'
	DB	'h status = 0x%08X', 0aH, 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FK@LLOCDNCM@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FK@LLOCDNCM@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:PsSetCreateProcessNotifyRoutine  fails'
	DB	' with status = 0x%08X', 0aH, 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FE@FMHNHJMB@DeviceControlDispatchRoutine?3ObR@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FE@FMHNHJMB@DeviceControlDispatchRoutine?3ObR@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:ObReferenceObjectByHandle  fails with '
	DB	'status = 0x%08X', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:Input buffer length = %d invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DE@EIMOCCFE@DeviceControlDispatchRoutine?3IOC@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DE@EIMOCCFE@DeviceControlDispatchRoutine?3IOC@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:IOCTL_START duplicate', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _DeviceControlDispatchRoutine@8
PAGE	SEGMENT
tv83 = -28						; size = 4
_outBufLen$ = -24					; size = 4
_status$ = -20						; size = 4
_ioStack$ = -16						; size = 4
_inBufLen$ = -12					; size = 4
_outBuf$ = -8						; size = 4
_inBuf$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DeviceControlDispatchRoutine@8 PROC			; COMDAT

; 96   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 97   : 	NTSTATUS				status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 98   : 	PIO_STACK_LOCATION		ioStack		= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 99   : 	ULONG					inBufLen		= ioStack->Parameters.DeviceIoControl.InputBufferLength;

	mov	ecx, DWORD PTR _ioStack$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _inBufLen$[ebp], edx

; 100  : 	ULONG					outBufLen	= ioStack->Parameters.DeviceIoControl.OutputBufferLength;

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _outBufLen$[ebp], ecx

; 101  : 	PHANDLE               			inBuf		= Irp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _inBuf$[ebp], eax

; 102  : 	PVOID               			outBuf		= Irp->AssociatedIrp.SystemBuffer;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _outBuf$[ebp], edx

; 103  : 	
; 104  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN21@DeviceCont
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	104					; 00000068H
	push	OFFSET ??_C@_0FD@GHCNPOAM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN21@DeviceCont:

; 105  : 	
; 106  : 	Irp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 107  : 	switch(ioStack->Parameters.DeviceIoControl.IoControlCode)

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv83[ebp], ecx
	mov	edx, DWORD PTR tv83[ebp]
	sub	edx, 2236416				; 00222000H
	mov	DWORD PTR tv83[ebp], edx
	cmp	DWORD PTR tv83[ebp], 12			; 0000000cH
	ja	$LN1@DeviceCont
	mov	eax, DWORD PTR tv83[ebp]
	movzx	ecx, BYTE PTR $LN24@DeviceCont[eax]
	jmp	DWORD PTR $LN25@DeviceCont[ecx*4]
$LN18@DeviceCont:

; 108  : 	{
; 109  : 		case IOCTL_START:
; 110  : 			if(gNotifyState)

	movzx	edx, BYTE PTR _gNotifyState
	test	edx, edx
	je	SHORT $LN17@DeviceCont

; 111  : 			{
; 112  : 				KdPrint( (__FUNCTION__":IOCTL_START duplicate\n") );

	push	OFFSET ??_C@_0DE@EIMOCCFE@DeviceControlDispatchRoutine?3IOC@NNGAKEGL@
	call	_DbgPrint
	add	esp, 4

; 113  : 				break;	

	jmp	$LN19@DeviceCont
$LN17@DeviceCont:

; 114  : 			}			
; 115  : 
; 116  : 			if(inBufLen != 2 * sizeof(HANDLE) )

	cmp	DWORD PTR _inBufLen$[ebp], 8
	je	SHORT $LN16@DeviceCont

; 117  : 			{
; 118  : 				KdPrint( (__FUNCTION__":Input buffer length = %d invalid\n", inBufLen) );

	mov	eax, DWORD PTR _inBufLen$[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 119  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 120  : 				break;

	jmp	$LN19@DeviceCont
$LN16@DeviceCont:

; 121  : 			}
; 122  : 			
; 123  : 			status = ObReferenceObjectByHandle(
; 124  : 								*inBuf, 
; 125  : 								EVENT_MODIFY_STATE, 
; 126  : 								*ExEventObjectType, 
; 127  : 								Irp->RequestorMode, 
; 128  : 								&gEventSendData, 
; 129  : 								NULL);

	push	0
	push	OFFSET _gEventSendData
	mov	ecx, DWORD PTR _Irp$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _ExEventObjectType
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	2
	mov	edx, DWORD PTR _inBuf$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ObReferenceObjectByHandle@24
	mov	DWORD PTR _status$[ebp], eax

; 130  : 			if( !NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN15@DeviceCont

; 131  : 			{
; 132  : 				KdPrint( (__FUNCTION__":ObReferenceObjectByHandle  fails with status = 0x%08X\n", status) );

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FE@FMHNHJMB@DeviceControlDispatchRoutine?3ObR@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 133  : 				break;

	jmp	$LN19@DeviceCont
$LN15@DeviceCont:

; 134  : 			}
; 135  : 			ObDereferenceObject(gEventSendData);

	mov	ecx, DWORD PTR _gEventSendData
	call	DWORD PTR __imp_@ObfDereferenceObject@4

; 136  : 			
; 137  : 			status = ObReferenceObjectByHandle(
; 138  : 								*(inBuf+1), 
; 139  : 								EVENT_MODIFY_STATE, 
; 140  : 								*ExEventObjectType, 
; 141  : 								Irp->RequestorMode, 
; 142  : 								&gEventImageSendData, 
; 143  : 								NULL);

	push	0
	push	OFFSET _gEventImageSendData
	mov	edx, DWORD PTR _Irp$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _ExEventObjectType
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	2
	mov	eax, DWORD PTR _inBuf$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__ObReferenceObjectByHandle@24
	mov	DWORD PTR _status$[ebp], eax

; 144  : 			if( !NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN14@DeviceCont

; 145  : 			{
; 146  : 				KdPrint( (__FUNCTION__":ObReferenceObjectByHandle  fails with status = 0x%08X\n", status) );

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0FE@FMHNHJMB@DeviceControlDispatchRoutine?3ObR@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 147  : 				break;

	jmp	$LN19@DeviceCont
$LN14@DeviceCont:

; 148  : 			}
; 149  : 			ObDereferenceObject(gEventImageSendData);

	mov	ecx, DWORD PTR _gEventImageSendData
	call	DWORD PTR __imp_@ObfDereferenceObject@4

; 150  : 			status = PsSetCreateProcessNotifyRoutine(&ProcessNotifyRoutine, FALSE);

	push	0
	push	OFFSET _ProcessNotifyRoutine@12
	call	DWORD PTR __imp__PsSetCreateProcessNotifyRoutine@8
	mov	DWORD PTR _status$[ebp], eax

; 151  : 			if( NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN13@DeviceCont

; 152  : 			{
; 153  : 				gNotifyState = TRUE;

	mov	BYTE PTR _gNotifyState, 1

; 154  : 			}
; 155  : 			else

	jmp	SHORT $LN12@DeviceCont
$LN13@DeviceCont:

; 156  : 			{
; 157  : 				KdPrint( (__FUNCTION__":PsSetCreateProcessNotifyRoutine  fails with status = 0x%08X\n", status) );					

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0FK@LLOCDNCM@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN12@DeviceCont:

; 158  : 			}
; 159  : 			
; 160  : 			status = PsSetLoadImageNotifyRoutine(&ImageNotifyRoutine);

	push	OFFSET _ImageNotifyRoutine@12
	call	DWORD PTR __imp__PsSetLoadImageNotifyRoutine@4
	mov	DWORD PTR _status$[ebp], eax

; 161  : 			if(! NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN11@DeviceCont

; 162  : 			{
; 163  : 				KdPrint( (__FUNCTION__":PsSetLoadImageNotifyRoutine  fails with status = 0x%08X\n", status) );

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FG@EHIMODJA@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN11@DeviceCont:

; 164  : 			}
; 165  : 			
; 166  : 			break;

	jmp	$LN19@DeviceCont
$LN10@DeviceCont:

; 167  : 			
; 168  : 		case IOCTL_STOP:
; 169  : 			if(gNotifyState)

	movzx	edx, BYTE PTR _gNotifyState
	test	edx, edx
	je	SHORT $LN9@DeviceCont

; 170  : 			{
; 171  : 				status = PsSetCreateProcessNotifyRoutine(&ProcessNotifyRoutine, TRUE);

	push	1
	push	OFFSET _ProcessNotifyRoutine@12
	call	DWORD PTR __imp__PsSetCreateProcessNotifyRoutine@8
	mov	DWORD PTR _status$[ebp], eax

; 172  : 				if ( NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN8@DeviceCont

; 173  : 				{
; 174  : 					gNotifyState = FALSE;

	mov	BYTE PTR _gNotifyState, 0

; 175  : 				}
; 176  : 				else

	jmp	SHORT $LN7@DeviceCont
$LN8@DeviceCont:

; 177  : 				{
; 178  : 					KdPrint( (__FUNCTION__":PsSetCreateProcessNotifyRoutine  fails with status = 0x%08X\n", status) );						

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0FK@LLOCDNCM@DeviceControlDispatchRoutine?3PsS@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN7@DeviceCont:

; 179  : 				}
; 180  : 				
; 181  : 				status = PsRemoveLoadImageNotifyRoutine(&ImageNotifyRoutine);

	push	OFFSET _ImageNotifyRoutine@12
	call	DWORD PTR __imp__PsRemoveLoadImageNotifyRoutine@4
	mov	DWORD PTR _status$[ebp], eax

; 182  : 				if(! NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN9@DeviceCont

; 183  : 				{
; 184  : 					KdPrint( (__FUNCTION__":PsRemoveLoadImageNotifyRoutine  fails with status = 0x%08X\n", status) );

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FJ@LHIJELAB@DeviceControlDispatchRoutine?3PsR@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN9@DeviceCont:

; 185  : 				}		
; 186  : 			}
; 187  : 			break;

	jmp	$LN19@DeviceCont
$LN5@DeviceCont:

; 188  : 			
; 189  : 		case IOCTL_GET_INFO:
; 190  : 			if( outBufLen < sizeof(PROCESS_NOTIFY_INFO) )

	cmp	DWORD PTR _outBufLen$[ebp], 12		; 0000000cH
	jae	SHORT $LN4@DeviceCont

; 191  : 			{
; 192  : 				KdPrint( (__FUNCTION__":Output buffer length = %d small\n", inBufLen) );

	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	push	OFFSET ??_C@_0DO@NBIAJJFI@DeviceControlDispatchRoutine?3Out@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 193  : 				status = STATUS_BUFFER_TOO_SMALL;

	mov	DWORD PTR _status$[ebp], -1073741789	; c0000023H

; 194  : 				break;

	jmp	$LN19@DeviceCont
$LN4@DeviceCont:

; 195  : 			}
; 196  : 			KeWaitForSingleObject(&gMutex, UserRequest, KernelMode, TRUE, NULL);

	push	0
	push	1
	push	0
	push	6
	push	OFFSET _gMutex
	call	DWORD PTR __imp__KeWaitForSingleObject@20

; 197  : 			memcpy(outBuf, &gProcessNotifyInfo, sizeof(PROCESS_NOTIFY_INFO) );

	mov	eax, DWORD PTR _outBuf$[ebp]
	mov	ecx, DWORD PTR _gProcessNotifyInfo
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _gProcessNotifyInfo+4
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _gProcessNotifyInfo+8
	mov	DWORD PTR [eax+8], ecx

; 198  : 			KeReleaseMutex(&gMutex, FALSE);

	push	0
	push	OFFSET _gMutex
	call	DWORD PTR __imp__KeReleaseMutex@8

; 199  : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 200  : 			Irp->IoStatus.Information = sizeof(PROCESS_NOTIFY_INFO);

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+28], 12			; 0000000cH

; 201  : 			break;

	jmp	SHORT $LN19@DeviceCont
$LN3@DeviceCont:

; 202  : 		case IOCTL_GET_IMAGE_INFO:
; 203  : 			if( outBufLen < sizeof(IMAGE_NOTIFY_INFO) )

	cmp	DWORD PTR _outBufLen$[ebp], 131080	; 00020008H
	jae	SHORT $LN2@DeviceCont

; 204  : 			{
; 205  : 				KdPrint( (__FUNCTION__":Output buffer length = %d small\n", inBufLen) );

	mov	eax, DWORD PTR _inBufLen$[ebp]
	push	eax
	push	OFFSET ??_C@_0DO@NBIAJJFI@DeviceControlDispatchRoutine?3Out@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 206  : 				status = STATUS_BUFFER_TOO_SMALL;

	mov	DWORD PTR _status$[ebp], -1073741789	; c0000023H

; 207  : 				break;

	jmp	SHORT $LN19@DeviceCont
$LN2@DeviceCont:

; 208  : 			}
; 209  : 			KeWaitForSingleObject(&gImageMutex, UserRequest, KernelMode, TRUE, NULL);

	push	0
	push	1
	push	0
	push	6
	push	OFFSET _gImageMutex
	call	DWORD PTR __imp__KeWaitForSingleObject@20

; 210  : 			memcpy(outBuf, &gProcessImageNotifyInfo, sizeof(IMAGE_NOTIFY_INFO) );

	push	131080					; 00020008H
	push	OFFSET _gProcessImageNotifyInfo
	mov	ecx, DWORD PTR _outBuf$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 211  : 			KeReleaseMutex(&gImageMutex, FALSE);

	push	0
	push	OFFSET _gImageMutex
	call	DWORD PTR __imp__KeReleaseMutex@8

; 212  : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 213  : 			Irp->IoStatus.Information = sizeof(IMAGE_NOTIFY_INFO);

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+28], 131080		; 00020008H
$LN1@DeviceCont:

; 214  : 		default:
; 215  : 			status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H
$LN19@DeviceCont:

; 216  : 			break;
; 217  : 	}	
; 218  : 		
; 219  : 	Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 220  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 221  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 222  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN25@DeviceCont:
	DD	$LN18@DeviceCont
	DD	$LN10@DeviceCont
	DD	$LN5@DeviceCont
	DD	$LN3@DeviceCont
	DD	$LN1@DeviceCont
$LN24@DeviceCont:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
_DeviceControlDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ DB 'c:\win'
	DB	'ddk\inc\ddk\wdm.h', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	push	0
	push	23317					; 00005b15H
	push	OFFSET ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
	push	OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 23319: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EJ@NHMKFLGJ@DriverUnload?3PsRemoveLoadImageNo@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EK@PIOLJHFG@DriverUnload?3PsSetCreateProcessN@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
;	COMDAT ??_C@_0EJ@NHMKFLGJ@DriverUnload?3PsRemoveLoadImageNo@NNGAKEGL@
; File c:\radasm\wdk\projects\driver_projects\pdlr08_gladyr\processnotify\processnotify.c
PAGE$s	SEGMENT
??_C@_0EJ@NHMKFLGJ@DriverUnload?3PsRemoveLoadImageNo@NNGAKEGL@ DB 'Driver'
	DB	'Unload:PsRemoveLoadImageNotifyRoutine  fails with status = 0x'
	DB	'%08X', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EK@PIOLJHFG@DriverUnload?3PsSetCreateProcessN@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EK@PIOLJHFG@DriverUnload?3PsSetCreateProcessN@NNGAKEGL@ DB 'Driver'
	DB	'Unload:PsSetCreateProcessNotifyRoutine  fails with status = 0'
	DB	'x%08X', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _DriverUnload@4
PAGE	SEGMENT
_status$ = -8						; size = 4
_DeviceObject$ = -4					; size = 4
_DriverObject$ = 8					; size = 4
_DriverUnload@4 PROC					; COMDAT

; 226  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 227  : 	PDEVICE_OBJECT	DeviceObject	= DriverObject->DeviceObject;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _DeviceObject$[ebp], ecx

; 228  : 	NTSTATUS		status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 229  : 	
; 230  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	cmp	edx, 1
	jle	SHORT $LN5@DriverUnlo
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	230					; 000000e6H
	push	OFFSET ??_C@_0FD@GHCNPOAM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN5@DriverUnlo:

; 231  : 
; 232  : 	if(gNotifyState)

	movzx	ecx, BYTE PTR _gNotifyState
	test	ecx, ecx
	je	SHORT $LN4@DriverUnlo

; 233  : 	{
; 234  : 		status = PsSetCreateProcessNotifyRoutine(&ProcessNotifyRoutine, TRUE);

	push	1
	push	OFFSET _ProcessNotifyRoutine@12
	call	DWORD PTR __imp__PsSetCreateProcessNotifyRoutine@8
	mov	DWORD PTR _status$[ebp], eax

; 235  : 		if ( !NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@DriverUnlo

; 236  : 		{
; 237  : 			KdPrint( (__FUNCTION__":PsSetCreateProcessNotifyRoutine  fails with status = 0x%08X\n", status) );						

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0EK@PIOLJHFG@DriverUnload?3PsSetCreateProcessN@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN3@DriverUnlo:

; 238  : 		}
; 239  : 		
; 240  : 		status = PsRemoveLoadImageNotifyRoutine(&ImageNotifyRoutine);

	push	OFFSET _ImageNotifyRoutine@12
	call	DWORD PTR __imp__PsRemoveLoadImageNotifyRoutine@4
	mov	DWORD PTR _status$[ebp], eax

; 241  : 		if(! NT_SUCCESS(status) )

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN4@DriverUnlo

; 242  : 		{
; 243  : 			KdPrint( (__FUNCTION__":PsRemoveLoadImageNotifyRoutine  fails with status = 0x%08X\n", status) );

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0EJ@NHMKFLGJ@DriverUnload?3PsRemoveLoadImageNo@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN4@DriverUnlo:

; 244  : 		}				
; 245  : 	}
; 246  : 
; 247  : 	IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 248  : 	if (DeviceObject != NULL)

	cmp	DWORD PTR _DeviceObject$[ebp], 0
	je	SHORT $LN6@DriverUnlo

; 249  : 	{
; 250  : 		IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN6@DriverUnlo:

; 251  : 	}
; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DriverUnload@4 ENDP
PAGE	ENDS
END
