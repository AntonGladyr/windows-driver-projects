; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviodemo\filedeviodemo.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deviceName_buffer
PUBLIC	_deviceName
PUBLIC	_symbolicLinkName_buffer
PUBLIC	_symbolicLinkName
CONST	SEGMENT
_deviceName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, '\', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'I', 00H, 'O', 00H, 'D', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 00H, 00H
_deviceName DW	02aH
	DW	02cH
	DD	FLAT:_deviceName_buffer
_symbolicLinkName_buffer DB '\', 00H, '?', 00H, '?', 00H, '\', 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'I'
	DB	00H, 'O', 00H, 'D', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 00H, 00H
_symbolicLinkName DW 022H
	DW	024H
	DD	FLAT:_symbolicLinkName_buffer
CONST	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_ReadDispatchRoutine@8
PUBLIC	_WriteDispatchRoutine@8
PUBLIC	_CloseDispatchRoutine@8
PUBLIC	_CreateDispatchRoutine@8
PUBLIC	??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_DriverEntry@8
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
EXTRN	__imp__ZwCreateFile@44:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@
; File c:\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviodemo\filedeviodemo.c
INIT$s	SEGMENT
??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@ DB 'Driv'
	DB	'erEntry : ZwCreateFile fails with status = 0x%08X', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@
INIT$s	SEGMENT
??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@ DB 'Drive'
	DB	'rEntry : IoCreateSymbolicLink fails with status = 0x%08X', 0aH
	DB	00H						;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@
INIT$s	SEGMENT
??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@ DB 'Driv'
	DB	'erEntry : IoCreateDevice fails with status = 0x%08X for devic'
	DB	'e with name %wZ', 0aH, 00H			;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@
INIT$s	SEGMENT
??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, 'C', 00H, ':', 00H, '\', 00H
	DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v'
	DB	00H, 'I', 00H, 'O', 00H, 'D', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, '.', 00H, 't', 00H, 'x', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_devFileName_buffer$ = -96				; size = 70
__$ArrayPad$ = -24					; size = 4
_status$ = -20						; size = 4
_DeviceObject$ = -16					; size = 4
_devFileName$ = -12					; size = 8
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 6    : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 7    : 	NTSTATUS			status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 8    : 	PDEVICE_OBJECT		DeviceObject	= NULL;

	mov	DWORD PTR _DeviceObject$[ebp], 0

; 9    : 	PDEVICE_EXTENSION	devExt		= NULL;

	mov	DWORD PTR _devExt$[ebp], 0

; 10   : 	
; 11   : 	DECLARE_CONST_UNICODE_STRING(devFileName, L"\\??\\C:\\FileDevIODemoDeviceFile.txt");

	mov	ecx, 17					; 00000011H
	mov	esi, OFFSET ??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@
	lea	edi, DWORD PTR _devFileName_buffer$[ebp]
	rep movsd
	movsw
	mov	eax, 68					; 00000044H
	mov	WORD PTR _devFileName$[ebp], ax
	mov	ecx, 70					; 00000046H
	mov	WORD PTR _devFileName$[ebp+2], cx
	lea	edx, DWORD PTR _devFileName_buffer$[ebp]
	mov	DWORD PTR _devFileName$[ebp+4], edx

; 12   : 
; 13   : 	UNREFERENCED_PARAMETER(RegistryPath);
; 14   : 
; 15   : 	status = IoCreateDevice(DriverObject,
; 16   : 						sizeof(DEVICE_EXTENSION),
; 17   : 						(PUNICODE_STRING)&deviceName,
; 18   : 						DEV_TYPE, FILE_DEVICE_SECURE_OPEN,
; 19   : 						FALSE, &DeviceObject);                        

	lea	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	push	34					; 00000022H
	push	OFFSET _deviceName
	push	56					; 00000038H
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 20   : 	
; 21   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@DriverEntr

; 22   : 	{
; 23   : 		KdPrint((__FUNCTION__" : IoCreateDevice fails with status = 0x%08X for device with name %wZ\n", 
; 24   : 					status, (PUNICODE_STRING)&deviceName) );

	push	OFFSET _deviceName
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 25   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN3@DriverEntr:

; 26   : 	}
; 27   : 	
; 28   : 	status = IoCreateSymbolicLink(	(PUNICODE_STRING)&symbolicLinkName, 
; 29   : 								(PUNICODE_STRING)&deviceName	);

	push	OFFSET _deviceName
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 30   : 		
; 31   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@DriverEntr

; 32   : 	{
; 33   : 		KdPrint((__FUNCTION__" : IoCreateSymbolicLink fails with status = 0x%08X\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 34   : 		IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 35   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN2@DriverEntr:

; 36   : 	}
; 37   : 	devExt = DeviceObject->DeviceExtension;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _devExt$[ebp], eax

; 38   : 	InitializeObjectAttributes(	&devExt->devFileAttr, 
; 39   : 							(PUNICODE_STRING)&devFileName,
; 40   : 							OBJ_CASE_INSENSITIVE+OBJ_KERNEL_HANDLE, 
; 41   : 							NULL,NULL	);

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+4], 24			; 00000018H
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+16], 576			; 00000240H
	mov	ecx, DWORD PTR _devExt$[ebp]
	lea	edx, DWORD PTR _devFileName$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 42   : 	
; 43   : 	status =  ZwCreateFile(&devExt->devFile,
; 44   : 		GENERIC_READ+GENERIC_WRITE,
; 45   : 		&devExt->devFileAttr,
; 46   : 		&devExt->devFileIoStatus,
; 47   : 		0, FILE_ATTRIBUTE_NORMAL,
; 48   :                 	FILE_SHARE_READ | FILE_SHARE_WRITE, 
; 49   :                 	FILE_OVERWRITE_IF,
; 50   : 		FILE_NON_DIRECTORY_FILE, NULL, 0);

	push	0
	push	0
	push	64					; 00000040H
	push	5
	push	3
	push	128					; 00000080H
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 4
	push	eax
	push	-1073741824				; c0000000H
	mov	ecx, DWORD PTR _devExt$[ebp]
	push	ecx
	call	DWORD PTR __imp__ZwCreateFile@44
	mov	DWORD PTR _status$[ebp], eax

; 51   : 	
; 52   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@DriverEntr

; 53   : 	{
; 54   : 		KdPrint((__FUNCTION__" : ZwCreateFile fails with status = 0x%08X\n", status));	

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 55   : 		IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 56   : 		IoDeleteDevice(DeviceObject);

	mov	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4

; 57   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN4@DriverEntr
$LN1@DriverEntr:

; 58   : 	}
; 59   : 
; 60   : 	devExt->writeOffset.LowPart = devExt->writeOffset.HighPart = 0;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 61   : 	devExt->readOffset.LowPart = devExt->readOffset.HighPart = 0;

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 62   : 	
; 63   : 	//DO_NEITHER_IO використовується за замовчанням і не потребує явного визначення
; 64   : 	//Для інших 
; 65   : 	//DeviceObject->Flags |= DO_BUFFERED_IO;
; 66   : 	//DeviceObject->Flags |= DO_DIRECT_IO;
; 67   : 			
; 68   : 	DriverObject->MajorFunction[IRP_MJ_CREATE]	= CreateDispatchRoutine;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+56], OFFSET _CreateDispatchRoutine@8

; 69   : 	DriverObject->MajorFunction[IRP_MJ_CLOSE]		= CloseDispatchRoutine;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+64], OFFSET _CloseDispatchRoutine@8

; 70   : 	DriverObject->MajorFunction[IRP_MJ_WRITE]		= WriteDispatchRoutine; 

	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [ecx+72], OFFSET _WriteDispatchRoutine@8

; 71   : 	DriverObject->MajorFunction[IRP_MJ_READ]		= ReadDispatchRoutine;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+68], OFFSET _ReadDispatchRoutine@8

; 72   : 			
; 73   : 	DriverObject->DriverUnload						= DriverUnload;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+52], OFFSET _DriverUnload@4

; 74   : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN4@DriverEntr:

; 75   : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
INIT	ENDS
PUBLIC	??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__RtlAssert@16:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
;	COMDAT ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@ DB 'Irp', 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_01GBGANLPD@0?$AA@NNGAKEGL@ DB '0', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ DB 'c:'
	DB	'\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviod'
	DB	'emo\filedeviodemo.c', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ DB 'E'
	DB	'X: Pageable code called at IRQL %d', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _CreateDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CreateDispatchRoutine@8 PROC				; COMDAT

; 80   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 81   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 82   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CreateDisp
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	82					; 00000052H
	push	OFFSET ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CreateDisp:

; 83   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CreateDisp
	push	0
	push	83					; 00000053H
	push	OFFSET ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CreateDisp
$LN4@CreateDisp:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CreateDisp:

; 84   : 
; 85   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 86   : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 87   : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 88   : 	return STATUS_SUCCESS;

	xor	eax, eax

; 89   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateDispatchRoutine@8 ENDP
; Function compile flags: /Odtp
PAGE	ENDS
;	COMDAT _CloseDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CloseDispatchRoutine@8 PROC				; COMDAT

; 94   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 95   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 96   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CloseDispa
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	96					; 00000060H
	push	OFFSET ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CloseDispa:

; 97   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CloseDispa
	push	0
	push	97					; 00000061H
	push	OFFSET ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CloseDispa
$LN4@CloseDispa:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CloseDispa:

; 98   : 
; 99   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 100  : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 101  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 102  : 	return STATUS_SUCCESS;

	xor	eax, eax

; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CloseDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CO@JPFHCINL@WriteDispatchRoutine?5?3?5Exception@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FC@NBKIDAJD@WriteDispatchRoutine?5?3?5MmGetSyst@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0ED@LJOPHPHM@WriteDispatchRoutine?5?3?5IoAllocat@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DM@EBKMHBJM@WriteDispatchRoutine?5?3?5Input?5buf@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	__imp__IoFreeMdl@4:PROC
EXTRN	__imp__MmUnlockPages@4:PROC
EXTRN	__imp__ZwWriteFile@36:PROC
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
EXTRN	__imp__MmProbeAndLockPages@12:PROC
EXTRN	__imp__IoAllocateMdl@20:PROC
EXTRN	__imp__ProbeForRead@12:PROC
EXTRN	__imp__MmUserProbeAddress:DWORD
EXTRN	__except_handler4:PROC
;	COMDAT ??_C@_0CO@JPFHCINL@WriteDispatchRoutine?5?3?5Exception@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CO@JPFHCINL@WriteDispatchRoutine?5?3?5Exception@NNGAKEGL@ DB 'Writ'
	DB	'eDispatchRoutine : Exception code 0x%08X', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@ DB 'Writ'
	DB	'eDispatchRoutine : ZwWriteFile fails with status = 0x%08X', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FC@NBKIDAJD@WriteDispatchRoutine?5?3?5MmGetSyst@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FC@NBKIDAJD@WriteDispatchRoutine?5?3?5MmGetSyst@NNGAKEGL@ DB 'Writ'
	DB	'eDispatchRoutine : MmGetSystemAddressForMdlSafe return 0x%p f'
	DB	'or input buffer', 0aH, 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0ED@LJOPHPHM@WriteDispatchRoutine?5?3?5IoAllocat@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0ED@LJOPHPHM@WriteDispatchRoutine?5?3?5IoAllocat@NNGAKEGL@ DB 'Writ'
	DB	'eDispatchRoutine : IoAllocateMdl return 0x%p for input buffer'
	DB	0aH, 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DM@EBKMHBJM@WriteDispatchRoutine?5?3?5Input?5buf@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DM@EBKMHBJM@WriteDispatchRoutine?5?3?5Input?5buf@NNGAKEGL@ DB 'Wri'
	DB	'teDispatchRoutine : Input buffer address = 0x%p invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_WriteDispatchRoutine@8 DD 0fffffffeH
	DD	00H
	DD	0ffffffb8H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN17@WriteDispa
	DD	FLAT:$LN18@WriteDispa
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT _WriteDispatchRoutine@8
PAGE	SEGMENT
tv148 = -56						; size = 4
$T23504 = -52						; size = 4
_status$ = -48						; size = 4
_mdl$ = -44						; size = 4
_ioStack$ = -40						; size = 4
_inBufLen$ = -36					; size = 4
_inBuf$ = -32						; size = 4
_devExt$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_WriteDispatchRoutine@8 PROC				; COMDAT

; 108  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$_WriteDispatchRoutine@8
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -40				; ffffffd8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 109  : 	NTSTATUS				status	= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 110  : 	PIO_STACK_LOCATION		ioStack	= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 111  : 	PDEVICE_EXTENSION		devExt	= DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _devExt$[ebp], edx

; 112  : 	ULONG					inBufLen	= ioStack->Parameters.Write.Length;

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _inBufLen$[ebp], ecx

; 113  : 	PCHAR               			inBuf	= NULL;

	mov	DWORD PTR _inBuf$[ebp], 0

; 114  : 	PMDL					mdl		= NULL;

	mov	DWORD PTR _mdl$[ebp], 0

; 115  : 
; 116  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	cmp	edx, 1
	jle	SHORT $LN11@WriteDispa
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN11@WriteDispa:

; 117  : //__debugbreak();
; 118  : 	Irp->IoStatus.Information = 0;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 119  : 	inBuf = Irp->UserBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _inBuf$[ebp], eax

; 120  : 	if((inBuf + inBufLen) >= (PCHAR)MM_USER_PROBE_ADDRESS ||
; 121  : 		inBuf <= (PCHAR)MM_LOWEST_USER_ADDRESS )

	mov	ecx, DWORD PTR _inBuf$[ebp]
	add	ecx, DWORD PTR _inBufLen$[ebp]
	mov	edx, DWORD PTR __imp__MmUserProbeAddress
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN9@WriteDispa
	cmp	DWORD PTR _inBuf$[ebp], 65536		; 00010000H
	ja	SHORT $LN10@WriteDispa
$LN9@WriteDispa:

; 122  : 	{
; 123  : 		KdPrint( (__FUNCTION__" : Input buffer address = 0x%p invalid\n", inBuf) );

	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	push	OFFSET ??_C@_0DM@EBKMHBJM@WriteDispatchRoutine?5?3?5Input?5buf@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 124  : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 125  : 		Irp->IoStatus.Status = status;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 126  : 		IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 127  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN16@WriteDispa
$LN10@WriteDispa:

; 128  : 	}
; 129  : 
; 130  : 	try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 131  : 	{
; 132  : 		ProbeForRead( inBuf, inBufLen, sizeof(UCHAR) );

	push	1
	mov	eax, DWORD PTR _inBufLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inBuf$[ebp]
	push	ecx
	call	DWORD PTR __imp__ProbeForRead@12

; 133  : 		mdl = IoAllocateMdl(inBuf, inBufLen, FALSE, TRUE, NULL);

	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	call	DWORD PTR __imp__IoAllocateMdl@20
	mov	DWORD PTR _mdl$[ebp], eax

; 134  : 		if (!mdl)

	cmp	DWORD PTR _mdl$[ebp], 0
	jne	SHORT $LN7@WriteDispa

; 135  : 		{
; 136  : 			KdPrint((__FUNCTION__" : IoAllocateMdl return 0x%p for input buffer\n", mdl));

	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	push	OFFSET ??_C@_0ED@LJOPHPHM@WriteDispatchRoutine?5?3?5IoAllocat@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 137  : 			status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 138  : 		}
; 139  : 		else

	jmp	$LN8@WriteDispa
$LN7@WriteDispa:

; 140  : 		{
; 141  : 			MmProbeAndLockPages(mdl, UserMode, IoReadAccess);

	push	0
	push	1
	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__MmProbeAndLockPages@12

; 142  : 			inBuf = MmGetSystemAddressForMdlSafe(mdl, NormalPagePriority);

	mov	eax, DWORD PTR _mdl$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	and	ecx, 5
	je	SHORT $LN14@WriteDispa
	mov	edx, DWORD PTR _mdl$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv148[ebp], eax
	jmp	SHORT $LN15@WriteDispa
$LN14@WriteDispa:
	push	16					; 00000010H
	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv148[ebp], eax
$LN15@WriteDispa:
	mov	edx, DWORD PTR tv148[ebp]
	mov	DWORD PTR _inBuf$[ebp], edx

; 143  : 			if (!inBuf)

	cmp	DWORD PTR _inBuf$[ebp], 0
	jne	SHORT $LN5@WriteDispa

; 144  : 			{
; 145  : 				status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 146  :    				KdPrint((__FUNCTION__" : MmGetSystemAddressForMdlSafe return 0x%p for input buffer\n", inBuf));

	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	push	OFFSET ??_C@_0FC@NBKIDAJD@WriteDispatchRoutine?5?3?5MmGetSyst@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 147  :    			}
; 148  :    			else

	jmp	SHORT $LN4@WriteDispa
$LN5@WriteDispa:

; 149  :    			{
; 150  : 				status = ZwWriteFile(	devExt->devFile,
; 151  : 									NULL, NULL, NULL,
; 152  : 									&devExt->devFileIoStatus,
; 153  : 									inBuf, inBufLen,
; 154  : 									&devExt->writeOffset, 
; 155  : 									NULL);

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwWriteFile@36
	mov	DWORD PTR _status$[ebp], eax

; 156  : 				if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN3@WriteDispa

; 157  : 				{
; 158  : 					devExt->writeOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 159  : 					Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx

; 160  : 				}
; 161  : 				else

	jmp	SHORT $LN4@WriteDispa
$LN3@WriteDispa:

; 162  : 				{
; 163  : 					KdPrint((__FUNCTION__" : ZwWriteFile fails with status = 0x%08X\n", status));

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN4@WriteDispa:

; 164  : 				}   					
; 165  :    			}
; 166  : 			MmUnlockPages(mdl);

	mov	eax, DWORD PTR _mdl$[ebp]
	push	eax
	call	DWORD PTR __imp__MmUnlockPages@4
$LN8@WriteDispa:

; 167  : 		}
; 168  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN20@WriteDispa
$LN17@WriteDispa:
$LN22@WriteDispa:

; 169  : 	except(EXCEPTION_EXECUTE_HANDLER)

	mov	ecx, DWORD PTR __$SEHRec$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T23504[ebp], eax
	mov	eax, 1
$LN19@WriteDispa:
$LN21@WriteDispa:
	ret	0
$LN18@WriteDispa:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 170  : 	{
; 171  : 		status = GetExceptionCode();

	mov	ecx, DWORD PTR $T23504[ebp]
	mov	DWORD PTR _status$[ebp], ecx

; 172  : 		KdPrint((__FUNCTION__" : Exception code 0x%08X\n", status));

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0CO@JPFHCINL@WriteDispatchRoutine?5?3?5Exception@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 173  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN20@WriteDispa:

; 174  : 		
; 175  : 	if(mdl)

	cmp	DWORD PTR _mdl$[ebp], 0
	je	SHORT $LN1@WriteDispa

; 176  : 	{
; 177  : 		IoFreeMdl(mdl);

	mov	eax, DWORD PTR _mdl$[ebp]
	push	eax
	call	DWORD PTR __imp__IoFreeMdl@4
$LN1@WriteDispa:

; 178  : 	}
; 179  : 
; 180  : 	Irp->IoStatus.Status = status;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 181  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 182  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN16@WriteDispa:

; 183  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_WriteDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ DB 'c:\win'
	DB	'ddk\inc\ddk\wdm.h', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	push	0
	push	23317					; 00005b15H
	push	OFFSET ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
	push	OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 23319: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@JNBJOOMA@ReadDispatchRoutine?5?3?5Exception?5@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FB@HIGMLDAD@ReadDispatchRoutine?5?3?5MmGetSyste@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0ED@MAEJENAO@ReadDispatchRoutine?5?3?5IoAllocate@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DM@CBMLFJPJ@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DJ@JCPHDDL@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	__imp__ProbeForWrite@12:PROC
;	COMDAT ??_C@_0CN@JNBJOOMA@ReadDispatchRoutine?5?3?5Exception?5@NNGAKEGL@
; File c:\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviodemo\filedeviodemo.c
PAGE$s	SEGMENT
??_C@_0CN@JNBJOOMA@ReadDispatchRoutine?5?3?5Exception?5@NNGAKEGL@ DB 'Rea'
	DB	'dDispatchRoutine : Exception code 0x%08X', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@ DB 'ReadD'
	DB	'ispatchRoutine : ZwReadFile fails with status = 0x%08X', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FB@HIGMLDAD@ReadDispatchRoutine?5?3?5MmGetSyste@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FB@HIGMLDAD@ReadDispatchRoutine?5?3?5MmGetSyste@NNGAKEGL@ DB 'Read'
	DB	'DispatchRoutine : MmGetSystemAddressForMdlSafe return 0x%p fo'
	DB	'r output buffer', 00H			;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0ED@MAEJENAO@ReadDispatchRoutine?5?3?5IoAllocate@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0ED@MAEJENAO@ReadDispatchRoutine?5?3?5IoAllocate@NNGAKEGL@ DB 'Read'
	DB	'DispatchRoutine : IoAllocateMdl return 0x%p for output buffer'
	DB	0aH, 00H					;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DM@CBMLFJPJ@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DM@CBMLFJPJ@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@ DB 'Rea'
	DB	'dDispatchRoutine : Output buffer address = 0x%p invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DJ@JCPHDDL@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DJ@JCPHDDL@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@ DB 'Read'
	DB	'DispatchRoutine : Output buffer length = %d invalid', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_ReadDispatchRoutine@8 DD 0fffffffeH
	DD	00H
	DD	0ffffffb8H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN18@ReadDispat
	DD	FLAT:$LN19@ReadDispat
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT _ReadDispatchRoutine@8
PAGE	SEGMENT
tv154 = -56						; size = 4
$T23526 = -52						; size = 4
_outBufLen$ = -48					; size = 4
_status$ = -44						; size = 4
_mdl$ = -40						; size = 4
_ioStack$ = -36						; size = 4
_outBuf$ = -32						; size = 4
_devExt$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ReadDispatchRoutine@8 PROC				; COMDAT

; 189  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$_ReadDispatchRoutine@8
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -40				; ffffffd8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 190  : 	NTSTATUS				status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 191  : 	PIO_STACK_LOCATION		ioStack		= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 192  : 	PDEVICE_EXTENSION		devExt		= DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _devExt$[ebp], edx

; 193  : 	ULONG					outBufLen	= ioStack->Parameters.Read.Length;

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _outBufLen$[ebp], ecx

; 194  : 	PCHAR					outBuf		= NULL;

	mov	DWORD PTR _outBuf$[ebp], 0

; 195  : 	PMDL					mdl			= NULL;

	mov	DWORD PTR _mdl$[ebp], 0

; 196  : 	
; 197  : 
; 198  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	cmp	edx, 1
	jle	SHORT $LN12@ReadDispat
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	198					; 000000c6H
	push	OFFSET ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN12@ReadDispat:

; 199  : //__debugbreak();
; 200  : 	Irp->IoStatus.Information = 0;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 201  : 	if (!outBufLen)

	cmp	DWORD PTR _outBufLen$[ebp], 0
	jne	SHORT $LN11@ReadDispat

; 202  : 	{
; 203  : 		KdPrint((__FUNCTION__" : Output buffer length = %d invalid\n", outBufLen));		

	mov	edx, DWORD PTR _outBufLen$[ebp]
	push	edx
	push	OFFSET ??_C@_0DJ@JCPHDDL@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 204  : 		Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+24], -1073741811		; c000000dH

; 205  : 		IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 206  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	$LN17@ReadDispat
$LN11@ReadDispat:

; 207  : 	}
; 208  : 	
; 209  : 	outBuf =  Irp->UserBuffer;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _outBuf$[ebp], edx

; 210  : 	if(	(outBuf + outBufLen) >= (PCHAR)MM_USER_PROBE_ADDRESS  ||
; 211  : 		outBuf <= (PCHAR)MM_LOWEST_USER_ADDRESS)

	mov	eax, DWORD PTR _outBuf$[ebp]
	add	eax, DWORD PTR _outBufLen$[ebp]
	mov	ecx, DWORD PTR __imp__MmUserProbeAddress
	cmp	eax, DWORD PTR [ecx]
	jae	SHORT $LN9@ReadDispat
	cmp	DWORD PTR _outBuf$[ebp], 65536		; 00010000H
	ja	SHORT $LN10@ReadDispat
$LN9@ReadDispat:

; 212  : 	{
; 213  : 		KdPrint( (__FUNCTION__" : Output buffer address = 0x%p invalid\n", outBuf) );

	mov	edx, DWORD PTR _outBuf$[ebp]
	push	edx
	push	OFFSET ??_C@_0DM@CBMLFJPJ@ReadDispatchRoutine?5?3?5Output?5buf@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 214  : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 215  : 		Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 216  : 		IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 217  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN17@ReadDispat
$LN10@ReadDispat:

; 218  : 	}
; 219  : 
; 220  : 	try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 221  : 	{
; 222  : 		ProbeForWrite( outBuf, outBufLen, sizeof(UCHAR) );

	push	1
	mov	edx, DWORD PTR _outBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _outBuf$[ebp]
	push	eax
	call	DWORD PTR __imp__ProbeForWrite@12

; 223  : 		mdl = IoAllocateMdl(outBuf, outBufLen, FALSE, TRUE, NULL);

	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _outBufLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outBuf$[ebp]
	push	edx
	call	DWORD PTR __imp__IoAllocateMdl@20
	mov	DWORD PTR _mdl$[ebp], eax

; 224  : 		if (!mdl)

	cmp	DWORD PTR _mdl$[ebp], 0
	jne	SHORT $LN7@ReadDispat

; 225  : 		{
; 226  : 			KdPrint((__FUNCTION__" : IoAllocateMdl return 0x%p for output buffer\n", mdl));

	mov	eax, DWORD PTR _mdl$[ebp]
	push	eax
	push	OFFSET ??_C@_0ED@MAEJENAO@ReadDispatchRoutine?5?3?5IoAllocate@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 227  : 			status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 228  : 		}
; 229  : 		else

	jmp	$LN8@ReadDispat
$LN7@ReadDispat:

; 230  : 		{
; 231  : 			MmProbeAndLockPages(mdl, UserMode, IoReadAccess);

	push	0
	push	1
	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	call	DWORD PTR __imp__MmProbeAndLockPages@12

; 232  : 			outBuf = MmGetSystemAddressForMdlSafe(mdl, NormalPagePriority);

	mov	edx, DWORD PTR _mdl$[ebp]
	movsx	eax, WORD PTR [edx+6]
	and	eax, 5
	je	SHORT $LN15@ReadDispat
	mov	ecx, DWORD PTR _mdl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv154[ebp], edx
	jmp	SHORT $LN16@ReadDispat
$LN15@ReadDispat:
	push	16					; 00000010H
	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _mdl$[ebp]
	push	eax
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv154[ebp], eax
$LN16@ReadDispat:
	mov	ecx, DWORD PTR tv154[ebp]
	mov	DWORD PTR _outBuf$[ebp], ecx

; 233  : 			if (!outBuf)

	cmp	DWORD PTR _outBuf$[ebp], 0
	jne	SHORT $LN5@ReadDispat

; 234  : 			{
; 235  : 				status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 236  : 				KdPrint((__FUNCTION__" : MmGetSystemAddressForMdlSafe return 0x%p for output buffer", outBuf));

	mov	edx, DWORD PTR _outBuf$[ebp]
	push	edx
	push	OFFSET ??_C@_0FB@HIGMLDAD@ReadDispatchRoutine?5?3?5MmGetSyste@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 237  : 			}
; 238  : 			else

	jmp	SHORT $LN4@ReadDispat
$LN5@ReadDispat:

; 239  : 			{
; 240  : 				status = ZwReadFile(	devExt->devFile,
; 241  : 									NULL, NULL, NULL,
; 242  : 									&devExt->devFileIoStatus,
; 243  : 									outBuf, outBufLen,
; 244  : 									&devExt->readOffset, NULL);

	push	0
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _outBufLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outBuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__ZwReadFile@36
	mov	DWORD PTR _status$[ebp], eax

; 245  : 				if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN3@ReadDispat

; 246  : 				{
; 247  : 					devExt->readOffset.LowPart += devExt->devFileIoStatus.Information;

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _devExt$[ebp]
	add	ecx, DWORD PTR [edx+32]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 248  : 					Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+28], eax

; 249  : 				}
; 250  : 				else

	jmp	SHORT $LN4@ReadDispat
$LN3@ReadDispat:

; 251  : 				{
; 252  : 					KdPrint((__FUNCTION__" : ZwReadFile fails with status = 0x%08X\n", status));

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN4@ReadDispat:

; 253  : 				}
; 254  : 			}
; 255  : 			MmUnlockPages(mdl);

	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__MmUnlockPages@4
$LN8@ReadDispat:

; 256  : 		}
; 257  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN21@ReadDispat
$LN18@ReadDispat:
$LN23@ReadDispat:

; 258  : 	except(EXCEPTION_EXECUTE_HANDLER)

	mov	eax, DWORD PTR __$SEHRec$[ebp+4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T23526[ebp], edx
	mov	eax, 1
$LN20@ReadDispat:
$LN22@ReadDispat:
	ret	0
$LN19@ReadDispat:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 259  : 	{
; 260  : 		status = GetExceptionCode();

	mov	eax, DWORD PTR $T23526[ebp]
	mov	DWORD PTR _status$[ebp], eax

; 261  : 		KdPrint((__FUNCTION__" : Exception code 0x%08X\n",status));

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CN@JNBJOOMA@ReadDispatchRoutine?5?3?5Exception?5@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 262  : 	}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN21@ReadDispat:

; 263  :         		
; 264  : 	if(mdl)

	cmp	DWORD PTR _mdl$[ebp], 0
	je	SHORT $LN1@ReadDispat

; 265  : 	{
; 266  : 		IoFreeMdl(mdl);

	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__IoFreeMdl@4
$LN1@ReadDispat:

; 267  : 	}
; 268  : 	
; 269  : 	Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 270  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 271  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN17@ReadDispat:

; 272  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_ReadDispatchRoutine@8 ENDP
PAGE	ENDS
EXTRN	__imp__ZwClose@4:PROC
; Function compile flags: /Odtp
;	COMDAT _DriverUnload@4
PAGE	SEGMENT
_DeviceObject$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_DriverUnload@4 PROC					; COMDAT

; 277  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 278  : 	PDEVICE_OBJECT		DeviceObject	= DriverObject->DeviceObject;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _DeviceObject$[ebp], ecx

; 279  : 	PDEVICE_EXTENSION	devExt		= DeviceObject->DeviceExtension;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _devExt$[ebp], eax

; 280  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	cmp	ecx, 1
	jle	SHORT $LN2@DriverUnlo
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	push	edx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	280					; 00000118H
	push	OFFSET ??_C@_0FD@LDJDEBAE@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN2@DriverUnlo:

; 281  : 
; 282  : 	ZwClose(devExt->devFile);

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__ZwClose@4

; 283  : 	IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 284  : 	if (DeviceObject != NULL)

	cmp	DWORD PTR _DeviceObject$[ebp], 0
	je	SHORT $LN3@DriverUnlo

; 285  : 	{
; 286  : 		IoDeleteDevice(DeviceObject);

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN3@DriverUnlo:

; 287  : 	}
; 288  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DriverUnload@4 ENDP
PAGE	ENDS
END
