; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviodemo_buffered\filedeviodemo.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deviceName_buffer
PUBLIC	_deviceName
PUBLIC	_symbolicLinkName_buffer
PUBLIC	_symbolicLinkName
CONST	SEGMENT
_deviceName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, '\', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'I', 00H, 'O', 00H, 'D', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 00H, 00H
_deviceName DW	02aH
	DW	02cH
	DD	FLAT:_deviceName_buffer
_symbolicLinkName_buffer DB '\', 00H, '?', 00H, '?', 00H, '\', 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'I'
	DB	00H, 'O', 00H, 'D', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 00H, 00H
_symbolicLinkName DW 022H
	DW	024H
	DD	FLAT:_symbolicLinkName_buffer
CONST	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_ReadDispatchRoutine@8
PUBLIC	_WriteDispatchRoutine@8
PUBLIC	_CloseDispatchRoutine@8
PUBLIC	_CreateDispatchRoutine@8
PUBLIC	??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_DriverEntry@8
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
EXTRN	__imp__ZwCreateFile@44:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@
; File c:\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviodemo_buffered\filedeviodemo.c
INIT$s	SEGMENT
??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@ DB 'Driv'
	DB	'erEntry : ZwCreateFile fails with status = 0x%08X', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@
INIT$s	SEGMENT
??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@ DB 'Drive'
	DB	'rEntry : IoCreateSymbolicLink fails with status = 0x%08X', 0aH
	DB	00H						;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@
INIT$s	SEGMENT
??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@ DB 'Driv'
	DB	'erEntry : IoCreateDevice fails with status = 0x%08X for devic'
	DB	'e with name %wZ', 0aH, 00H			;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@
INIT$s	SEGMENT
??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, 'C', 00H, ':', 00H, '\', 00H
	DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v'
	DB	00H, 'I', 00H, 'O', 00H, 'D', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, '.', 00H, 't', 00H, 'x', 00H
	DB	't', 00H, 00H, 00H				;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_devFileName_buffer$ = -96				; size = 70
__$ArrayPad$ = -24					; size = 4
_status$ = -20						; size = 4
_DeviceObject$ = -16					; size = 4
_devFileName$ = -12					; size = 8
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 6    : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 7    : 	NTSTATUS			status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 8    : 	PDEVICE_OBJECT		DeviceObject	= NULL;

	mov	DWORD PTR _DeviceObject$[ebp], 0

; 9    : 	PDEVICE_EXTENSION	devExt		= NULL;

	mov	DWORD PTR _devExt$[ebp], 0

; 10   : 	
; 11   : 	DECLARE_CONST_UNICODE_STRING(devFileName, L"\\??\\C:\\FileDevIODemoDeviceFile.txt");

	mov	ecx, 17					; 00000011H
	mov	esi, OFFSET ??_C@_1EG@OJPEHMCE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl?$AAe?$AA?4?$AAt@PBOPGDP@
	lea	edi, DWORD PTR _devFileName_buffer$[ebp]
	rep movsd
	movsw
	mov	eax, 68					; 00000044H
	mov	WORD PTR _devFileName$[ebp], ax
	mov	ecx, 70					; 00000046H
	mov	WORD PTR _devFileName$[ebp+2], cx
	lea	edx, DWORD PTR _devFileName_buffer$[ebp]
	mov	DWORD PTR _devFileName$[ebp+4], edx

; 12   : 
; 13   : 	UNREFERENCED_PARAMETER(RegistryPath);
; 14   : 
; 15   : 	status = IoCreateDevice(DriverObject,
; 16   : 						sizeof(DEVICE_EXTENSION),
; 17   : 						(PUNICODE_STRING)&deviceName,
; 18   : 						DEV_TYPE, FILE_DEVICE_SECURE_OPEN,
; 19   : 						FALSE, &DeviceObject);                        

	lea	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	push	34					; 00000022H
	push	OFFSET _deviceName
	push	56					; 00000038H
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 20   : 	
; 21   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@DriverEntr

; 22   : 	{
; 23   : 		KdPrint((__FUNCTION__" : IoCreateDevice fails with status = 0x%08X for device with name %wZ\n", 
; 24   : 					status, (PUNICODE_STRING)&deviceName) );

	push	OFFSET _deviceName
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0FC@MPHHJFBB@DriverEntry?5?3?5IoCreateDevice?5fai@PBOPGDP@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 25   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN3@DriverEntr:

; 26   : 	}
; 27   : 	
; 28   : 	status = IoCreateSymbolicLink(	(PUNICODE_STRING)&symbolicLinkName, 
; 29   : 								(PUNICODE_STRING)&deviceName	);

	push	OFFSET _deviceName
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 30   : 		
; 31   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@DriverEntr

; 32   : 	{
; 33   : 		KdPrint((__FUNCTION__" : IoCreateSymbolicLink fails with status = 0x%08X\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@HDKPMLLC@DriverEntry?5?3?5IoCreateSymbolicLi@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 34   : 		IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 35   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN2@DriverEntr:

; 36   : 	}
; 37   : 	devExt = DeviceObject->DeviceExtension;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _devExt$[ebp], eax

; 38   : 	InitializeObjectAttributes(	&devExt->devFileAttr, 
; 39   : 							(PUNICODE_STRING)&devFileName,
; 40   : 							OBJ_CASE_INSENSITIVE+OBJ_KERNEL_HANDLE, 
; 41   : 							NULL,NULL	);

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+4], 24			; 00000018H
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+16], 576			; 00000240H
	mov	ecx, DWORD PTR _devExt$[ebp]
	lea	edx, DWORD PTR _devFileName$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 42   : 	
; 43   : 	status =  ZwCreateFile(&devExt->devFile,
; 44   : 		GENERIC_READ+GENERIC_WRITE,
; 45   : 		&devExt->devFileAttr,
; 46   : 		&devExt->devFileIoStatus,
; 47   : 		0, FILE_ATTRIBUTE_NORMAL,
; 48   :                 	FILE_SHARE_READ | FILE_SHARE_WRITE, 
; 49   :                 	FILE_OVERWRITE_IF,
; 50   : 		FILE_NON_DIRECTORY_FILE, NULL, 0);

	push	0
	push	0
	push	64					; 00000040H
	push	5
	push	3
	push	128					; 00000080H
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 4
	push	eax
	push	-1073741824				; c0000000H
	mov	ecx, DWORD PTR _devExt$[ebp]
	push	ecx
	call	DWORD PTR __imp__ZwCreateFile@44
	mov	DWORD PTR _status$[ebp], eax

; 51   : 	
; 52   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@DriverEntr

; 53   : 	{
; 54   : 		KdPrint((__FUNCTION__" : ZwCreateFile fails with status = 0x%08X\n", status));	

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 55   : 		IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 56   : 		IoDeleteDevice(DeviceObject);

	mov	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4

; 57   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN4@DriverEntr
$LN1@DriverEntr:

; 58   : 	}
; 59   : 
; 60   : 	devExt->writeOffset.LowPart = devExt->writeOffset.HighPart = 0;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 61   : 	devExt->readOffset.LowPart = devExt->readOffset.HighPart = 0;

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 62   : 	
; 63   : 	//DO_NEITHER_IO використовується за замовчанням і не потребує явного визначення
; 64   : 	//Для інших 
; 65   : 	DeviceObject->Flags |= DO_BUFFERED_IO;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+28]
	or	eax, 4
	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 66   : 	//DeviceObject->Flags |= DO_DIRECT_IO;
; 67   : 			
; 68   : 	DriverObject->MajorFunction[IRP_MJ_CREATE]	= CreateDispatchRoutine;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+56], OFFSET _CreateDispatchRoutine@8

; 69   : 	DriverObject->MajorFunction[IRP_MJ_CLOSE]		= CloseDispatchRoutine;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+64], OFFSET _CloseDispatchRoutine@8

; 70   : 	DriverObject->MajorFunction[IRP_MJ_WRITE]		= WriteDispatchRoutine; 

	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [ecx+72], OFFSET _WriteDispatchRoutine@8

; 71   : 	DriverObject->MajorFunction[IRP_MJ_READ]		= ReadDispatchRoutine;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+68], OFFSET _ReadDispatchRoutine@8

; 72   : 			
; 73   : 	DriverObject->DriverUnload						= DriverUnload;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+52], OFFSET _DriverUnload@4

; 74   : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN4@DriverEntr:

; 75   : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
INIT	ENDS
PUBLIC	??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__RtlAssert@16:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
;	COMDAT ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@ DB 'Irp', 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_01GBGANLPD@0?$AA@NNGAKEGL@ DB '0', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ DB 'c:'
	DB	'\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviod'
	DB	'emo_buffered\filedeviodemo.c', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ DB 'E'
	DB	'X: Pageable code called at IRQL %d', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _CreateDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CreateDispatchRoutine@8 PROC				; COMDAT

; 80   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 81   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 82   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CreateDisp
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	82					; 00000052H
	push	OFFSET ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CreateDisp:

; 83   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CreateDisp
	push	0
	push	83					; 00000053H
	push	OFFSET ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CreateDisp
$LN4@CreateDisp:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CreateDisp:

; 84   : 
; 85   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 86   : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 87   : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 88   : 	return STATUS_SUCCESS;

	xor	eax, eax

; 89   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateDispatchRoutine@8 ENDP
; Function compile flags: /Odtp
PAGE	ENDS
;	COMDAT _CloseDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CloseDispatchRoutine@8 PROC				; COMDAT

; 94   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 95   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 96   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CloseDispa
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	96					; 00000060H
	push	OFFSET ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CloseDispa:

; 97   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CloseDispa
	push	0
	push	97					; 00000061H
	push	OFFSET ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CloseDispa
$LN4@CloseDispa:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CloseDispa:

; 98   : 
; 99   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 100  : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 101  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 102  : 	return STATUS_SUCCESS;

	xor	eax, eax

; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CloseDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	__imp__ZwWriteFile@36:PROC
;	COMDAT ??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@ DB 'Writ'
	DB	'eDispatchRoutine : ZwWriteFile fails with status = 0x%08X', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _WriteDispatchRoutine@8
PAGE	SEGMENT
_status$ = -24						; size = 4
_mdl$ = -20						; size = 4
_ioStack$ = -16						; size = 4
_inBufLen$ = -12					; size = 4
_inBuf$ = -8						; size = 4
_devExt$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_WriteDispatchRoutine@8 PROC				; COMDAT

; 108  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 109  : 	NTSTATUS				status	= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 110  : 	PIO_STACK_LOCATION		ioStack	= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 111  : 	PDEVICE_EXTENSION		devExt	= DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _devExt$[ebp], edx

; 112  : 	ULONG					inBufLen	= ioStack->Parameters.Write.Length;

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _inBufLen$[ebp], ecx

; 113  : 	PCHAR               			inBuf	= NULL;

	mov	DWORD PTR _inBuf$[ebp], 0

; 114  : 	PMDL					mdl		= NULL;

	mov	DWORD PTR _mdl$[ebp], 0

; 115  : 
; 116  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	cmp	edx, 1
	jle	SHORT $LN3@WriteDispa
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	116					; 00000074H
	push	OFFSET ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN3@WriteDispa:

; 117  : 	Irp->IoStatus.Information = 0;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 118  : 	inBuf = Irp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _inBuf$[ebp], eax

; 119  : 
; 120  : 	status = ZwWriteFile(	devExt->devFile,
; 121  : 						NULL, NULL, NULL,
; 122  : 						&devExt->devFileIoStatus,
; 123  : 						inBuf, inBufLen,
; 124  : 						&devExt->writeOffset, 
; 125  : 						NULL);

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwWriteFile@36
	mov	DWORD PTR _status$[ebp], eax

; 126  : 	if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN2@WriteDispa

; 127  : 	{
; 128  : 		devExt->writeOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 129  : 		Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx

; 130  : 	}
; 131  : 	else

	jmp	SHORT $LN1@WriteDispa
$LN2@WriteDispa:

; 132  : 	{
; 133  : 		KdPrint((__FUNCTION__" : ZwWriteFile fails with status = 0x%08X\n", status));

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0DP@LOHGJBGO@WriteDispatchRoutine?5?3?5ZwWriteFi@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN1@WriteDispa:

; 134  : 	}   					
; 135  : 
; 136  : 	Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 137  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 138  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_WriteDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ DB 'c:\win'
	DB	'ddk\inc\ddk\wdm.h', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	push	0
	push	23317					; 00005b15H
	push	OFFSET ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
	push	OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 23319: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp__ZwReadFile@36:PROC
;	COMDAT ??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@
; File c:\radasm\wdk\projects\driver_projects\pdlr04_gladyr\filedeviodemo_buffered\filedeviodemo.c
PAGE$s	SEGMENT
??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@ DB 'ReadD'
	DB	'ispatchRoutine : ZwReadFile fails with status = 0x%08X', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _ReadDispatchRoutine@8
PAGE	SEGMENT
_outBufLen$ = -24					; size = 4
_status$ = -20						; size = 4
_mdl$ = -16						; size = 4
_ioStack$ = -12						; size = 4
_outBuf$ = -8						; size = 4
_devExt$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ReadDispatchRoutine@8 PROC				; COMDAT

; 145  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 146  : 	NTSTATUS				status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 147  : 	PIO_STACK_LOCATION		ioStack		= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 148  : 	PDEVICE_EXTENSION		devExt		= DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _devExt$[ebp], edx

; 149  : 	ULONG					outBufLen	= ioStack->Parameters.Read.Length;

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _outBufLen$[ebp], ecx

; 150  : 	PCHAR					outBuf		= NULL;

	mov	DWORD PTR _outBuf$[ebp], 0

; 151  : 	PMDL					mdl			= NULL;

	mov	DWORD PTR _mdl$[ebp], 0

; 152  : 	
; 153  : 
; 154  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	cmp	edx, 1
	jle	SHORT $LN3@ReadDispat
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	push	eax
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	154					; 0000009aH
	push	OFFSET ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN3@ReadDispat:

; 155  : 	Irp->IoStatus.Information = 0;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 156  : 	outBuf =  Irp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _outBuf$[ebp], eax

; 157  : 	status = ZwReadFile(	devExt->devFile,
; 158  : 						NULL, NULL, NULL,
; 159  : 						&devExt->devFileIoStatus,
; 160  : 						outBuf, outBufLen,
; 161  : 						&devExt->readOffset, NULL);

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	edx, DWORD PTR _outBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _outBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwReadFile@36
	mov	DWORD PTR _status$[ebp], eax

; 162  : 	if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN2@ReadDispat

; 163  : 	{
; 164  : 		devExt->readOffset.LowPart += devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 165  : 		Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx

; 166  : 	}
; 167  : 	else

	jmp	SHORT $LN1@ReadDispat
$LN2@ReadDispat:

; 168  : 	{
; 169  : 		KdPrint((__FUNCTION__" : ZwReadFile fails with status = 0x%08X\n", status));

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0DN@CCMKAPM@ReadDispatchRoutine?5?3?5ZwReadFile@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
$LN1@ReadDispat:

; 170  : 	}
; 171  : 	
; 172  : 	Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 173  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 174  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_ReadDispatchRoutine@8 ENDP
PAGE	ENDS
EXTRN	__imp__ZwClose@4:PROC
; Function compile flags: /Odtp
;	COMDAT _DriverUnload@4
PAGE	SEGMENT
_DeviceObject$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_DriverUnload@4 PROC					; COMDAT

; 180  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 181  : 	PDEVICE_OBJECT		DeviceObject	= DriverObject->DeviceObject;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _DeviceObject$[ebp], ecx

; 182  : 	PDEVICE_EXTENSION	devExt		= DeviceObject->DeviceExtension;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _devExt$[ebp], eax

; 183  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	cmp	ecx, 1
	jle	SHORT $LN2@DriverUnlo
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	push	edx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	183					; 000000b7H
	push	OFFSET ??_C@_0FM@FIGLMKDM@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN2@DriverUnlo:

; 184  : 
; 185  : 	ZwClose(devExt->devFile);

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__ZwClose@4

; 186  : 	IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 187  : 	if (DeviceObject != NULL)

	cmp	DWORD PTR _DeviceObject$[ebp], 0
	je	SHORT $LN3@DriverUnlo

; 188  : 	{
; 189  : 		IoDeleteDevice(DeviceObject);

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN3@DriverUnlo:

; 190  : 	}
; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DriverUnload@4 ENDP
PAGE	ENDS
END
