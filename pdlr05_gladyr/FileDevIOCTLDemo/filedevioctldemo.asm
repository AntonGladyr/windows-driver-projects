; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr05_gladyr\filedevioctldemo\filedevioctldemo.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deviceName_buffer
PUBLIC	_deviceName
PUBLIC	_symbolicLinkName_buffer
PUBLIC	_symbolicLinkName
CONST	SEGMENT
_deviceName_buffer DB '\', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, '\', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T'
	DB	00H, 'L', 00H, 'D', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 00H, 00H
	ORG $+2
_deviceName DW	030H
	DW	032H
	DD	FLAT:_deviceName_buffer
_symbolicLinkName_buffer DB '\', 00H, '?', 00H, '?', 00H, '\', 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'I'
	DB	00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, 'D', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 00H, 00H
	ORG $+2
_symbolicLinkName DW 028H
	DW	02aH
	DD	FLAT:_symbolicLinkName_buffer
CONST	ENDS
PUBLIC	_DriverUnload@4
PUBLIC	_DeviceControlDispatchRoutine@8
PUBLIC	_CreateCloseDispatchRoutine@8
PUBLIC	??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	??_C@_1EM@PLABCLGE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAC?$AAT?$AAL?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl@PBOPGDP@ ;  ?? ::PBOPGDP::`string'
PUBLIC	__$ArrayPad$
PUBLIC	_DriverEntry@8
EXTRN	__imp__IoDeleteSymbolicLink@4:PROC
EXTRN	__imp__ZwCreateFile@44:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@
; File c:\radasm\wdk\projects\driver_projects\pdlr05_gladyr\filedevioctldemo\filedevioctldemo.c
INIT$s	SEGMENT
??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@ DB 'Driv'
	DB	'erEntry : ZwCreateFile fails with status = 0x%08X', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@
INIT$s	SEGMENT
??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@ DB 'DriverE'
	DB	'ntry:IoCreateSymbolicLink fails with status = 0x%08X', 0aH, 00H ;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@
INIT$s	SEGMENT
??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@ DB 'Driver'
	DB	'Entry:IoCreateDevice fails with status = 0x%08X for device wi'
	DB	'th name %wZ', 0aH, 00H			;  ?? ::PBOPGDP::`string'
INIT$s	ENDS
;	COMDAT ??_C@_1EM@PLABCLGE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAC?$AAT?$AAL?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl@PBOPGDP@
INIT$s	SEGMENT
??_C@_1EM@PLABCLGE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAC?$AAT?$AAL?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl@PBOPGDP@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, 'C', 00H, ':', 00H, '\', 00H
	DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v'
	DB	00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H, 'L', 00H, 'D', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i'
	DB	00H, 'c', 00H, 'e', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'.', 00H, 't', 00H, 'x', 00H, 't', 00H, 00H, 00H ;  ?? ::PBOPGDP::`string'
; Function compile flags: /Odtp
INIT$s	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_devFileName_buffer$ = -104				; size = 76
__$ArrayPad$ = -24					; size = 4
_status$ = -20						; size = 4
_DeviceObject$ = -16					; size = 4
_devFileName$ = -12					; size = 8
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 7    : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 8    : 	NTSTATUS			status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 9    : 	PDEVICE_OBJECT		DeviceObject	= NULL;

	mov	DWORD PTR _DeviceObject$[ebp], 0

; 10   : 	PDEVICE_EXTENSION	devExt		= NULL;

	mov	DWORD PTR _devExt$[ebp], 0

; 11   : 	
; 12   : 	DECLARE_CONST_UNICODE_STRING(devFileName, L"\\??\\C:\\FileDevIOCTLDemoDeviceFile.txt");

	mov	ecx, 19					; 00000013H
	mov	esi, OFFSET ??_C@_1EM@PLABCLGE@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AAC?$AA?3?$AA?2?$AAF?$AAi?$AAl?$AAe?$AAD?$AAe?$AAv?$AAI?$AAO?$AAC?$AAT?$AAL?$AAD?$AAe?$AAm?$AAo?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAF?$AAi?$AAl@PBOPGDP@
	lea	edi, DWORD PTR _devFileName_buffer$[ebp]
	rep movsd
	mov	eax, 74					; 0000004aH
	mov	WORD PTR _devFileName$[ebp], ax
	mov	ecx, 76					; 0000004cH
	mov	WORD PTR _devFileName$[ebp+2], cx
	lea	edx, DWORD PTR _devFileName_buffer$[ebp]
	mov	DWORD PTR _devFileName$[ebp+4], edx

; 13   : 
; 14   : 	UNREFERENCED_PARAMETER(RegistryPath);
; 15   : 
; 16   : 	status = IoCreateDevice(DriverObject,
; 17   : 							sizeof(DEVICE_EXTENSION),
; 18   : 							(PUNICODE_STRING)&deviceName,
; 19   : 							DEV_TYPE, FILE_DEVICE_SECURE_OPEN,
; 20   : 							FALSE, &DeviceObject);                        

	lea	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	push	0
	push	256					; 00000100H
	push	34					; 00000022H
	push	OFFSET _deviceName
	push	56					; 00000038H
	mov	ecx, DWORD PTR _DriverObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 21   : 	
; 22   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@DriverEntr

; 23   : 	{
; 24   : 		KdPrint((__FUNCTION__":IoCreateDevice fails with status = 0x%08X for device with name %wZ\n", 
; 25   : 					status, (PUNICODE_STRING)&deviceName) );

	push	OFFSET _deviceName
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0FA@EDLJHCJH@DriverEntry?3IoCreateDevice?5fails@PBOPGDP@
	call	_DbgPrint
	add	esp, 12					; 0000000cH

; 26   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN3@DriverEntr:

; 27   : 	}
; 28   : 	
; 29   : 	status = IoCreateSymbolicLink(	(PUNICODE_STRING)&symbolicLinkName, 
; 30   : 									(PUNICODE_STRING)&deviceName	);

	push	OFFSET _deviceName
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 31   : 		
; 32   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@DriverEntr

; 33   : 	{
; 34   : 		KdPrint((__FUNCTION__":IoCreateSymbolicLink fails with status = 0x%08X\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@MPNLHDFJ@DriverEntry?3IoCreateSymbolicLink@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 35   : 		IoDeleteDevice(DeviceObject);

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoDeleteDevice@4

; 36   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN4@DriverEntr
$LN2@DriverEntr:

; 37   : 	}
; 38   : 	
; 39   : 	devExt = DeviceObject->DeviceExtension;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _devExt$[ebp], eax

; 40   : 	InitializeObjectAttributes(	&devExt->devFileAttr, 
; 41   : 							(PUNICODE_STRING)&devFileName,
; 42   : 							OBJ_CASE_INSENSITIVE+OBJ_KERNEL_HANDLE, 
; 43   : 							NULL,NULL	);

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+4], 24			; 00000018H
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+16], 576			; 00000240H
	mov	ecx, DWORD PTR _devExt$[ebp]
	lea	edx, DWORD PTR _devFileName$[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 44   : 	
; 45   : 	status =  ZwCreateFile(&devExt->devFile,
; 46   : 				GENERIC_READ+GENERIC_WRITE,
; 47   : 				&devExt->devFileAttr,
; 48   : 				&devExt->devFileIoStatus,
; 49   : 				0, FILE_ATTRIBUTE_NORMAL,
; 50   : 	         	       	FILE_SHARE_READ | FILE_SHARE_WRITE, 
; 51   :          	       		FILE_OVERWRITE_IF,
; 52   : 				FILE_NON_DIRECTORY_FILE, NULL, 0);

	push	0
	push	0
	push	64					; 00000040H
	push	5
	push	3
	push	128					; 00000080H
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 4
	push	eax
	push	-1073741824				; c0000000H
	mov	ecx, DWORD PTR _devExt$[ebp]
	push	ecx
	call	DWORD PTR __imp__ZwCreateFile@44
	mov	DWORD PTR _status$[ebp], eax

; 53   : 	
; 54   : 	if (!NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@DriverEntr

; 55   : 	{
; 56   : 		KdPrint((__FUNCTION__" : ZwCreateFile fails with status = 0x%08X\n", status));	

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0DH@EGIDKENK@DriverEntry?5?3?5ZwCreateFile?5fails@PBOPGDP@
	call	_DbgPrint
	add	esp, 8

; 57   : 		IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 58   : 		IoDeleteDevice(DeviceObject);

	mov	eax, DWORD PTR _DeviceObject$[ebp]
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4

; 59   : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN4@DriverEntr
$LN1@DriverEntr:

; 60   : 	}
; 61   : 
; 62   : 	devExt->writeOffset.LowPart = devExt->writeOffset.HighPart = 0;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [edx+40], 0

; 63   : 	devExt->readOffset.LowPart = devExt->readOffset.HighPart = 0;

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 64   : 
; 65   : 	DriverObject->MajorFunction[IRP_MJ_CREATE]			= CreateCloseDispatchRoutine; 

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+56], OFFSET _CreateCloseDispatchRoutine@8

; 66   : 	DriverObject->MajorFunction[IRP_MJ_CLOSE]				= CreateCloseDispatchRoutine;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [eax+64], OFFSET _CreateCloseDispatchRoutine@8

; 67   : 	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]	= DeviceControlDispatchRoutine;

	mov	ecx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [ecx+112], OFFSET _DeviceControlDispatchRoutine@8

; 68   : 	DriverObject->DriverUnload								= DriverUnload;

	mov	edx, DWORD PTR _DriverObject$[ebp]
	mov	DWORD PTR [edx+52], OFFSET _DriverUnload@4

; 69   : 
; 70   : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN4@DriverEntr:

; 71   : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
INIT	ENDS
PUBLIC	??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@NNGAKEGL@		;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FJ@LFPODNJI@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
EXTRN	__imp_@IofCompleteRequest@8:PROC
EXTRN	__imp__RtlAssert@16:PROC
EXTRN	__imp__KeGetCurrentIrql@0:PROC
;	COMDAT ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@ DB 'Irp', 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_01GBGANLPD@0?$AA@NNGAKEGL@ DB '0', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FJ@LFPODNJI@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FJ@LFPODNJI@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@ DB 'c:'
	DB	'\radasm\wdk\projects\driver_projects\pdlr05_gladyr\filedevioc'
	DB	'tldemo\filedevioctldemo.c', 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@ DB 'E'
	DB	'X: Pageable code called at IRQL %d', 0aH, 00H ;  ?? ::NNGAKEGL::`string'
; Function compile flags: /Odtp
PAGE$s	ENDS
;	COMDAT _CreateCloseDispatchRoutine@8
PAGE	SEGMENT
tv80 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_CreateCloseDispatchRoutine@8 PROC			; COMDAT

; 76   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 77   : 	UNREFERENCED_PARAMETER(DeviceObject);
; 78   : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	eax, al
	cmp	eax, 1
	jle	SHORT $LN1@CreateClos
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	push	ecx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	78					; 0000004eH
	push	OFFSET ??_C@_0FJ@LFPODNJI@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN1@CreateClos:

; 79   : 	ASSERT(Irp);

	cmp	DWORD PTR _Irp$[ebp], 0
	jne	SHORT $LN4@CreateClos
	push	0
	push	79					; 0000004fH
	push	OFFSET ??_C@_0FJ@LFPODNJI@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_03EAONPCJM@Irp?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN5@CreateClos
$LN4@CreateClos:
	mov	DWORD PTR tv80[ebp], 1
$LN5@CreateClos:

; 80   : 
; 81   : 	Irp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 82   : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 83   : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 84   : 	return STATUS_SUCCESS;

	xor	eax, eax

; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateCloseDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0GF@EGAIGGPL@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EK@DPHHOJII@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FO@LFKICPDF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0ED@IPGEHMED@DeviceControlDispatchRoutine?3out@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FI@IOMLCFCF@DeviceControlDispatchRoutine?3MmG@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0GE@DIJFCLAH@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EJ@JLKCPMAO@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0FN@CBKNKNBF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EC@OOCNIJMB@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0EA@MOJFIADF@DeviceControlDispatchRoutine?3Out@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@ ;  ?? ::NNGAKEGL::`string'
PUBLIC	_IoGetCurrentIrpStackLocation@4
EXTRN	__imp__MmUnlockPages@4:PROC
EXTRN	__imp__IoFreeMdl@4:PROC
EXTRN	__imp__MmProbeAndLockPages@12:PROC
EXTRN	__imp__IoAllocateMdl@20:PROC
EXTRN	__imp__ProbeForRead@12:PROC
EXTRN	__imp__MmUserProbeAddress:DWORD
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
EXTRN	__imp__ZwReadFile@36:PROC
EXTRN	__imp__ZwWriteFile@36:PROC
EXTRN	__except_handler4:PROC
;	COMDAT ??_C@_0GF@EGAIGGPL@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0GF@EGAIGGPL@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:MmProbeAndLockPages raise exception wi'
	DB	'th code 0x%08X for output buffer', 0aH, 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EK@DPHHOJII@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EK@DPHHOJII@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:IoAllocateMdl return 0x%p for output b'
	DB	'uffer', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FO@LFKICPDF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FO@LFKICPDF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:ProbeForRead raise exception with code'
	DB	' 0x%08X for output buffer', 0aH, 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0ED@IPGEHMED@DeviceControlDispatchRoutine?3out@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0ED@IPGEHMED@DeviceControlDispatchRoutine?3out@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:output buffer address = 0x%p invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FI@IOMLCFCF@DeviceControlDispatchRoutine?3MmG@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FI@IOMLCFCF@DeviceControlDispatchRoutine?3MmG@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:MmGetSystemAddressForMdlSafe return 0x'
	DB	'%p for input buffer', 0aH, 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0GE@DIJFCLAH@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0GE@DIJFCLAH@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:MmProbeAndLockPages raise exception wi'
	DB	'th code 0x%08X for input buffer', 0aH, 00H	;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EJ@JLKCPMAO@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EJ@JLKCPMAO@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:IoAllocateMdl return 0x%p for input bu'
	DB	'ffer', 0aH, 00H				;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0FN@CBKNKNBF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0FN@CBKNKNBF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:ProbeForRead raise exception with code'
	DB	' 0x%08X for input buffer', 0aH, 00H		;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EC@OOCNIJMB@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EC@OOCNIJMB@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:Input buffer address = 0x%p invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0EA@MOJFIADF@DeviceControlDispatchRoutine?3Out@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0EA@MOJFIADF@DeviceControlDispatchRoutine?3Out@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:Output buffer length = %d invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT ??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
PAGE$s	SEGMENT
??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@ DB 'Device'
	DB	'ControlDispatchRoutine:Input buffer length = %d invalid', 0aH
	DB	00H						;  ?? ::NNGAKEGL::`string'
PAGE$s	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_DeviceControlDispatchRoutine@8 DD 0fffffffeH
	DD	00H
	DD	0ffffff98H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN46@DeviceCont
	DD	FLAT:$LN47@DeviceCont
	DD	0fffffffeH
	DD	FLAT:$LN50@DeviceCont
	DD	FLAT:$LN51@DeviceCont
	DD	0fffffffeH
	DD	FLAT:$LN54@DeviceCont
	DD	FLAT:$LN55@DeviceCont
	DD	0fffffffeH
	DD	FLAT:$LN58@DeviceCont
	DD	FLAT:$LN59@DeviceCont
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT _DeviceControlDispatchRoutine@8
PAGE	SEGMENT
tv341 = -88						; size = 4
tv276 = -84						; size = 4
tv209 = -80						; size = 4
tv82 = -76						; size = 4
$T18074 = -72						; size = 4
$T18073 = -68						; size = 4
$T18072 = -64						; size = 4
$T18071 = -60						; size = 4
_outBufLen$ = -56					; size = 4
_status$ = -52						; size = 4
_mdl$ = -48						; size = 4
_ioStack$ = -44						; size = 4
_inBufLen$ = -40					; size = 4
_outBuf$ = -36						; size = 4
_inBuf$ = -32						; size = 4
_devExt$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_DeviceControlDispatchRoutine@8 PROC			; COMDAT

; 90   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$_DeviceControlDispatchRoutine@8
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -72				; ffffffb8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 91   : 	NTSTATUS				status		= STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 92   : 	PIO_STACK_LOCATION		ioStack		= IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _ioStack$[ebp], eax

; 93   : 	PDEVICE_EXTENSION		devExt		= DeviceObject->DeviceExtension;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _devExt$[ebp], edx

; 94   : 	ULONG					inBufLen		= ioStack->Parameters.DeviceIoControl.InputBufferLength;

	mov	eax, DWORD PTR _ioStack$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _inBufLen$[ebp], ecx

; 95   : 	ULONG					outBufLen	= ioStack->Parameters.DeviceIoControl.OutputBufferLength;

	mov	edx, DWORD PTR _ioStack$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _outBufLen$[ebp], eax

; 96   : 	PMDL					mdl			= NULL;

	mov	DWORD PTR _mdl$[ebp], 0

; 97   : 	PCHAR               			inBuf		= NULL;

	mov	DWORD PTR _inBuf$[ebp], 0

; 98   : 	PCHAR               			outBuf		= NULL;

	mov	DWORD PTR _outBuf$[ebp], 0

; 99   : 
; 100  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	cmp	ecx, 1
	jle	SHORT $LN36@DeviceCont
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	push	edx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	100					; 00000064H
	push	OFFSET ??_C@_0FJ@LFPODNJI@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN36@DeviceCont:

; 101  : 	
; 102  : 	Irp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 103  : 	
; 104  : 	switch(ioStack->Parameters.DeviceIoControl.IoControlCode)

	mov	ecx, DWORD PTR _ioStack$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR tv82[ebp]
	sub	eax, 2236416				; 00222000H
	mov	DWORD PTR tv82[ebp], eax
	cmp	DWORD PTR tv82[ebp], 7
	ja	$LN1@DeviceCont
	mov	ecx, DWORD PTR tv82[ebp]
	jmp	DWORD PTR $LN66@DeviceCont[ecx*4]
$LN33@DeviceCont:

; 105  : 	{
; 106  : 		case IOCTL_BUFFERED_WRITE:
; 107  : 			if(inBufLen > IN_BUFFER_SIZE || !inBufLen)

	cmp	DWORD PTR _inBufLen$[ebp], 256		; 00000100H
	ja	SHORT $LN31@DeviceCont
	cmp	DWORD PTR _inBufLen$[ebp], 0
	jne	SHORT $LN32@DeviceCont
$LN31@DeviceCont:

; 108  : 			{
; 109  : 				KdPrint( (__FUNCTION__":Input buffer length = %d invalid\n", inBufLen) );

	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	push	OFFSET ??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 110  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 111  : 				Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 112  : 				IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 113  : 				return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN45@DeviceCont
$LN32@DeviceCont:

; 114  : 			}
; 115  : 			inBuf = Irp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _inBuf$[ebp], eax

; 116  : 			status = ZwWriteFile(devExt->devFile,
; 117  : 							NULL, NULL, NULL,
; 118  : 							&devExt->devFileIoStatus,
; 119  : 							inBuf, inBufLen,
; 120  : 							&devExt->writeOffset, 
; 121  : 							NULL);	

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwWriteFile@36
	mov	DWORD PTR _status$[ebp], eax

; 122  : 			if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN30@DeviceCont

; 123  : 			{
; 124  : 				devExt->writeOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 125  : 				Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx
$LN30@DeviceCont:

; 126  : 			}			
; 127  : 			break;

	jmp	$LN34@DeviceCont
$LN29@DeviceCont:

; 128  : 			
; 129  : 		case IOCTL_BUFFERED_READ:
; 130  : 			if(outBufLen > OUT_BUFFER_SIZE || !outBufLen)

	cmp	DWORD PTR _outBufLen$[ebp], 256		; 00000100H
	ja	SHORT $LN27@DeviceCont
	cmp	DWORD PTR _outBufLen$[ebp], 0
	jne	SHORT $LN28@DeviceCont
$LN27@DeviceCont:

; 131  : 			{
; 132  : 				KdPrint( (__FUNCTION__":Output buffer length = %d invalid\n", outBufLen) );

	mov	edx, DWORD PTR _outBufLen$[ebp]
	push	edx
	push	OFFSET ??_C@_0EA@MOJFIADF@DeviceControlDispatchRoutine?3Out@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 133  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 134  : 				Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 135  : 				IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 136  : 				return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN45@DeviceCont
$LN28@DeviceCont:

; 137  : 			}
; 138  : 			outBuf = Irp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _outBuf$[ebp], eax

; 139  : 			status = ZwReadFile(devExt->devFile,
; 140  : 							NULL, NULL, NULL,
; 141  : 							&devExt->devFileIoStatus,
; 142  : 							outBuf, outBufLen,
; 143  : 							&devExt->readOffset, 
; 144  : 							NULL);	

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	edx, DWORD PTR _outBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _outBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwReadFile@36
	mov	DWORD PTR _status$[ebp], eax

; 145  : 			if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN26@DeviceCont

; 146  : 			{
; 147  : 				devExt->readOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 148  : 				Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx
$LN26@DeviceCont:

; 149  : 			}			
; 150  : 			break;

	jmp	$LN34@DeviceCont
$LN25@DeviceCont:

; 151  : 		
; 152  : 		case IOCTL_DIRECT_WRITE:
; 153  : 			if(inBufLen > IN_BUFFER_SIZE || !inBufLen)

	cmp	DWORD PTR _inBufLen$[ebp], 256		; 00000100H
	ja	SHORT $LN23@DeviceCont
	cmp	DWORD PTR _inBufLen$[ebp], 0
	jne	SHORT $LN24@DeviceCont
$LN23@DeviceCont:

; 154  : 			{
; 155  : 				KdPrint( (__FUNCTION__":Input buffer length = %d invalid\n", inBufLen) );

	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	push	OFFSET ??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 156  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 157  : 				Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 158  : 				IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 159  : 				return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN45@DeviceCont
$LN24@DeviceCont:

; 160  : 			}
; 161  : 			inBuf	= Irp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _inBuf$[ebp], eax

; 162  : 			status = ZwWriteFile(devExt->devFile,
; 163  : 							NULL, NULL, NULL,
; 164  : 							&devExt->devFileIoStatus,
; 165  : 							inBuf, inBufLen,
; 166  : 							&devExt->writeOffset, 
; 167  : 							NULL);	

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwWriteFile@36
	mov	DWORD PTR _status$[ebp], eax

; 168  : 			if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN22@DeviceCont

; 169  : 			{
; 170  : 				devExt->writeOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 171  : 				Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx
$LN22@DeviceCont:

; 172  : 			}			
; 173  : 			break;

	jmp	$LN34@DeviceCont
$LN21@DeviceCont:

; 174  : 		
; 175  : 		case IOCTL_DIRECT_READ:
; 176  : 			mdl = Irp->MdlAddress;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _mdl$[ebp], eax

; 177  : 			outBuf = MmGetSystemAddressForMdlSafe(mdl, NormalPagePriority);

	mov	ecx, DWORD PTR _mdl$[ebp]
	movsx	edx, WORD PTR [ecx+6]
	and	edx, 5
	je	SHORT $LN39@DeviceCont
	mov	eax, DWORD PTR _mdl$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR tv209[ebp], ecx
	jmp	SHORT $LN40@DeviceCont
$LN39@DeviceCont:
	push	16					; 00000010H
	push	0
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv209[ebp], eax
$LN40@DeviceCont:
	mov	eax, DWORD PTR tv209[ebp]
	mov	DWORD PTR _outBuf$[ebp], eax

; 178  : 			status = ZwReadFile(devExt->devFile,
; 179  : 							NULL, NULL, NULL,
; 180  : 							&devExt->devFileIoStatus,
; 181  : 							outBuf, outBufLen,
; 182  : 							&devExt->readOffset, 
; 183  : 							NULL);	

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	edx, DWORD PTR _outBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _outBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwReadFile@36
	mov	DWORD PTR _status$[ebp], eax

; 184  : 			if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN20@DeviceCont

; 185  : 			{
; 186  : 				devExt->readOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 187  : 				Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx
$LN20@DeviceCont:

; 188  : 			}			
; 189  : 			break;

	jmp	$LN34@DeviceCont
$LN19@DeviceCont:

; 190  : 
; 191  : 		case IOCTL_NEITHER_WRITE:
; 192  : 			if(inBufLen > IN_BUFFER_SIZE || !inBufLen)

	cmp	DWORD PTR _inBufLen$[ebp], 256		; 00000100H
	ja	SHORT $LN17@DeviceCont
	cmp	DWORD PTR _inBufLen$[ebp], 0
	jne	SHORT $LN18@DeviceCont
$LN17@DeviceCont:

; 193  : 			{
; 194  : 				KdPrint( (__FUNCTION__":Input buffer length = %d invalid\n", inBufLen) );

	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	push	OFFSET ??_C@_0DP@HLDLJDOO@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 195  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 196  : 				Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 197  : 				IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 198  : 				return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN45@DeviceCont
$LN18@DeviceCont:

; 199  : 			}
; 200  : 			inBuf	= ioStack->Parameters.DeviceIoControl.Type3InputBuffer;

	mov	edx, DWORD PTR _ioStack$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _inBuf$[ebp], eax

; 201  : 			// перевіряємо чи розташовані буфери в адресному просторі режиму користувача
; 202  : 			if((inBuf + inBufLen) >= (PCHAR)MM_USER_PROBE_ADDRESS ||
; 203  : 				inBuf <= (PCHAR)MM_LOWEST_USER_ADDRESS )

	mov	ecx, DWORD PTR _inBuf$[ebp]
	add	ecx, DWORD PTR _inBufLen$[ebp]
	mov	edx, DWORD PTR __imp__MmUserProbeAddress
	cmp	ecx, DWORD PTR [edx]
	jae	SHORT $LN15@DeviceCont
	cmp	DWORD PTR _inBuf$[ebp], 65536		; 00010000H
	ja	SHORT $LN16@DeviceCont
$LN15@DeviceCont:

; 204  : 			{
; 205  : 				KdPrint( (__FUNCTION__":Input buffer address = 0x%p invalid\n", inBuf) );

	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	push	OFFSET ??_C@_0EC@OOCNIJMB@DeviceControlDispatchRoutine?3Inp@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 206  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 207  : 				break;

	jmp	$LN34@DeviceCont
$LN16@DeviceCont:

; 208  : 			}
; 209  : 			// перевіряємо вирівнювання і доступність для читання вхідного буфера
; 210  : 			try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 211  : 			{
; 212  : 				ProbeForRead( inBuf, inBufLen, sizeof(UCHAR) );

	push	1
	mov	ecx, DWORD PTR _inBufLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inBuf$[ebp]
	push	edx
	call	DWORD PTR __imp__ProbeForRead@12

; 213  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN49@DeviceCont
$LN46@DeviceCont:
$LN67@DeviceCont:

; 214  : 			except(EXCEPTION_EXECUTE_HANDLER)

	mov	eax, DWORD PTR __$SEHRec$[ebp+4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T18071[ebp], edx
	mov	eax, 1
$LN48@DeviceCont:
$LN62@DeviceCont:
	ret	0
$LN47@DeviceCont:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 215  : 			{
; 216  : 				status = GetExceptionCode();

	mov	eax, DWORD PTR $T18071[ebp]
	mov	DWORD PTR _status$[ebp], eax

; 217  : 				KdPrint((__FUNCTION__":ProbeForRead raise exception with code 0x%08X for input buffer\n", status));

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FN@CBKNKNBF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 218  : 				break;

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	$LN34@DeviceCont

; 219  :        			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN49@DeviceCont:

; 220  : 
; 221  : 			mdl = IoAllocateMdl(inBuf, inBufLen, FALSE, TRUE, NULL);

	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	call	DWORD PTR __imp__IoAllocateMdl@20
	mov	DWORD PTR _mdl$[ebp], eax

; 222  : 			if(!mdl)

	cmp	DWORD PTR _mdl$[ebp], 0
	jne	SHORT $LN13@DeviceCont

; 223  : 			{
; 224  : 				KdPrint((__FUNCTION__":IoAllocateMdl return 0x%p for input buffer\n", mdl));

	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EJ@JLKCPMAO@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 225  : 				status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 226  : 				break;

	jmp	$LN34@DeviceCont
$LN13@DeviceCont:

; 227  : 			}
; 228  : 								
; 229  : 			try

	mov	DWORD PTR __$SEHRec$[ebp+20], 1

; 230  : 			{
; 231  : 				MmProbeAndLockPages(mdl, UserMode, IoReadAccess);

	push	0
	push	1
	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__MmProbeAndLockPages@12

; 232  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN53@DeviceCont
$LN50@DeviceCont:
$LN68@DeviceCont:

; 233  : 			except(EXCEPTION_EXECUTE_HANDLER)

	mov	eax, DWORD PTR __$SEHRec$[ebp+4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T18072[ebp], edx
	mov	eax, 1
$LN52@DeviceCont:
$LN63@DeviceCont:
	ret	0
$LN51@DeviceCont:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 234  : 			{
; 235  : 				status = GetExceptionCode();

	mov	eax, DWORD PTR $T18072[ebp]
	mov	DWORD PTR _status$[ebp], eax

; 236  : 				KdPrint((__FUNCTION__":MmProbeAndLockPages raise exception with code 0x%08X for input buffer\n", status));

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0GE@DIJFCLAH@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 237  : 				IoFreeMdl(mdl);

	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__IoFreeMdl@4

; 238  : 				break;

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	$LN34@DeviceCont

; 239  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN53@DeviceCont:

; 240  : 					
; 241  : 			inBuf = MmGetSystemAddressForMdlSafe(mdl, NormalPagePriority);

	mov	eax, DWORD PTR _mdl$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	and	ecx, 5
	je	SHORT $LN41@DeviceCont
	mov	edx, DWORD PTR _mdl$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv276[ebp], eax
	jmp	SHORT $LN42@DeviceCont
$LN41@DeviceCont:
	push	16					; 00000010H
	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv276[ebp], eax
$LN42@DeviceCont:
	mov	edx, DWORD PTR tv276[ebp]
	mov	DWORD PTR _inBuf$[ebp], edx

; 242  : 			if (!inBuf)

	cmp	DWORD PTR _inBuf$[ebp], 0
	jne	SHORT $LN11@DeviceCont

; 243  : 			{
; 244  : 				status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 245  :         				KdPrint((__FUNCTION__":MmGetSystemAddressForMdlSafe return 0x%p for input buffer\n", inBuf));

	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	push	OFFSET ??_C@_0FI@IOMLCFCF@DeviceControlDispatchRoutine?3MmG@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 246  :        				break;

	jmp	$LN34@DeviceCont
$LN11@DeviceCont:

; 247  :    			}
; 248  : 			status = ZwWriteFile(devExt->devFile,
; 249  : 							NULL, NULL, NULL,
; 250  : 							&devExt->devFileIoStatus,
; 251  : 							inBuf, inBufLen,
; 252  : 							&devExt->writeOffset, 
; 253  : 							NULL);	

	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	edx, DWORD PTR _inBufLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _devExt$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__ZwWriteFile@36
	mov	DWORD PTR _status$[ebp], eax

; 254  : 			if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN10@DeviceCont

; 255  : 			{
; 256  : 				devExt->writeOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _devExt$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [ecx+40], edx

; 257  : 				Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+28], ecx
$LN10@DeviceCont:

; 258  : 			}
; 259  : 			MmUnlockPages(mdl);

	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__MmUnlockPages@4

; 260  : 			IoFreeMdl(mdl);

	mov	eax, DWORD PTR _mdl$[ebp]
	push	eax
	call	DWORD PTR __imp__IoFreeMdl@4

; 261  : 			break;

	jmp	$LN34@DeviceCont
$LN9@DeviceCont:

; 262  : 			
; 263  : 		case IOCTL_NEITHER_READ:
; 264  : 			outBuf	=Irp->UserBuffer;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _outBuf$[ebp], edx

; 265  : 			// перевіряємо чи розташовані буфери в адресному просторі режиму користувача
; 266  : 			if((outBuf + outBufLen) >= (PCHAR)MM_USER_PROBE_ADDRESS ||
; 267  : 				outBuf <= (PCHAR)MM_LOWEST_USER_ADDRESS )

	mov	eax, DWORD PTR _outBuf$[ebp]
	add	eax, DWORD PTR _outBufLen$[ebp]
	mov	ecx, DWORD PTR __imp__MmUserProbeAddress
	cmp	eax, DWORD PTR [ecx]
	jae	SHORT $LN7@DeviceCont
	cmp	DWORD PTR _outBuf$[ebp], 65536		; 00010000H
	ja	SHORT $LN8@DeviceCont
$LN7@DeviceCont:

; 268  : 			{
; 269  : 				KdPrint( (__FUNCTION__":output buffer address = 0x%p invalid\n", outBuf) );

	mov	edx, DWORD PTR _outBuf$[ebp]
	push	edx
	push	OFFSET ??_C@_0ED@IPGEHMED@DeviceControlDispatchRoutine?3out@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 270  : 				status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 271  : 				break;

	jmp	$LN34@DeviceCont
$LN8@DeviceCont:

; 272  : 			}
; 273  : 			// перевіряємо вирівнювання і доступність для читання вхідного буфера
; 274  : 			try

	mov	DWORD PTR __$SEHRec$[ebp+20], 2

; 275  : 			{
; 276  : 				ProbeForRead( outBuf, outBufLen, sizeof(UCHAR) );

	push	1
	mov	eax, DWORD PTR _outBufLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outBuf$[ebp]
	push	ecx
	call	DWORD PTR __imp__ProbeForRead@12

; 277  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN57@DeviceCont
$LN54@DeviceCont:
$LN69@DeviceCont:

; 278  : 			except(EXCEPTION_EXECUTE_HANDLER)

	mov	edx, DWORD PTR __$SEHRec$[ebp+4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T18073[ebp], ecx
	mov	eax, 1
$LN56@DeviceCont:
$LN64@DeviceCont:
	ret	0
$LN55@DeviceCont:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 279  : 			{
; 280  : 				status = GetExceptionCode();

	mov	edx, DWORD PTR $T18073[ebp]
	mov	DWORD PTR _status$[ebp], edx

; 281  : 				KdPrint((__FUNCTION__":ProbeForRead raise exception with code 0x%08X for output buffer\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0FO@LFKICPDF@DeviceControlDispatchRoutine?3Pro@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 282  : 				break;

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	$LN34@DeviceCont

; 283  :        			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN57@DeviceCont:

; 284  : 
; 285  : 			mdl = IoAllocateMdl(outBuf, outBufLen, FALSE, TRUE, NULL);

	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _outBufLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outBuf$[ebp]
	push	edx
	call	DWORD PTR __imp__IoAllocateMdl@20
	mov	DWORD PTR _mdl$[ebp], eax

; 286  : 			if(!mdl)

	cmp	DWORD PTR _mdl$[ebp], 0
	jne	SHORT $LN5@DeviceCont

; 287  : 			{
; 288  : 				KdPrint((__FUNCTION__":IoAllocateMdl return 0x%p for output buffer\n", mdl));

	mov	eax, DWORD PTR _mdl$[ebp]
	push	eax
	push	OFFSET ??_C@_0EK@DPHHOJII@DeviceControlDispatchRoutine?3IoA@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 289  : 				status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 290  : 				break;

	jmp	$LN34@DeviceCont
$LN5@DeviceCont:

; 291  : 			}
; 292  : 								
; 293  : 			try

	mov	DWORD PTR __$SEHRec$[ebp+20], 3

; 294  : 			{
; 295  : 				MmProbeAndLockPages(mdl, UserMode, IoReadAccess);

	push	0
	push	1
	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	call	DWORD PTR __imp__MmProbeAndLockPages@12

; 296  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN61@DeviceCont
$LN58@DeviceCont:
$LN70@DeviceCont:

; 297  : 			except(EXCEPTION_EXECUTE_HANDLER)

	mov	edx, DWORD PTR __$SEHRec$[ebp+4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T18074[ebp], ecx
	mov	eax, 1
$LN60@DeviceCont:
$LN65@DeviceCont:
	ret	0
$LN59@DeviceCont:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 298  : 			{
; 299  : 				status = GetExceptionCode();

	mov	edx, DWORD PTR $T18074[ebp]
	mov	DWORD PTR _status$[ebp], edx

; 300  : 				KdPrint((__FUNCTION__":MmProbeAndLockPages raise exception with code 0x%08X for output buffer\n", status));

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0GF@EGAIGGPL@DeviceControlDispatchRoutine?3MmP@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 301  : 				IoFreeMdl(mdl);

	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoFreeMdl@4

; 302  : 				break;

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	$LN34@DeviceCont

; 303  : 			}

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN61@DeviceCont:

; 304  : 					
; 305  : 			outBuf = MmGetSystemAddressForMdlSafe(mdl, NormalPagePriority);

	mov	edx, DWORD PTR _mdl$[ebp]
	movsx	eax, WORD PTR [edx+6]
	and	eax, 5
	je	SHORT $LN43@DeviceCont
	mov	ecx, DWORD PTR _mdl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv341[ebp], edx
	jmp	SHORT $LN44@DeviceCont
$LN43@DeviceCont:
	push	16					; 00000010H
	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _mdl$[ebp]
	push	eax
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv341[ebp], eax
$LN44@DeviceCont:
	mov	ecx, DWORD PTR tv341[ebp]
	mov	DWORD PTR _outBuf$[ebp], ecx

; 306  : 			if (!outBuf)

	cmp	DWORD PTR _outBuf$[ebp], 0
	jne	SHORT $LN3@DeviceCont

; 307  : 			{
; 308  : 				status = STATUS_INSUFFICIENT_RESOURCES;

	mov	DWORD PTR _status$[ebp], -1073741670	; c000009aH

; 309  :         				KdPrint((__FUNCTION__":MmGetSystemAddressForMdlSafe return 0x%p for input buffer\n", inBuf));

	mov	edx, DWORD PTR _inBuf$[ebp]
	push	edx
	push	OFFSET ??_C@_0FI@IOMLCFCF@DeviceControlDispatchRoutine?3MmG@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8

; 310  :        				break;

	jmp	SHORT $LN34@DeviceCont
$LN3@DeviceCont:

; 311  :    			}
; 312  : 			status = ZwReadFile(devExt->devFile,
; 313  : 							NULL, NULL, NULL,
; 314  : 							&devExt->devFileIoStatus,
; 315  : 							outBuf, outBufLen,
; 316  : 							&devExt->readOffset, 
; 317  : 							NULL);	

	push	0
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _outBufLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outBuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _devExt$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _devExt$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__ZwReadFile@36
	mov	DWORD PTR _status$[ebp], eax

; 318  : 			if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN2@DeviceCont

; 319  : 			{
; 320  : 				devExt->readOffset.LowPart+=devExt->devFileIoStatus.Information;

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _devExt$[ebp]
	add	ecx, DWORD PTR [edx+32]
	mov	eax, DWORD PTR _devExt$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 321  : 				Irp->IoStatus.Information = devExt->devFileIoStatus.Information;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR _devExt$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+28], eax
$LN2@DeviceCont:

; 322  : 			}
; 323  : 			MmUnlockPages(mdl);

	mov	ecx, DWORD PTR _mdl$[ebp]
	push	ecx
	call	DWORD PTR __imp__MmUnlockPages@4

; 324  : 			IoFreeMdl(mdl);

	mov	edx, DWORD PTR _mdl$[ebp]
	push	edx
	call	DWORD PTR __imp__IoFreeMdl@4

; 325  : 			break;

	jmp	SHORT $LN34@DeviceCont
$LN1@DeviceCont:

; 326  : 			
; 327  : 		default:
; 328  : 			status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H
$LN34@DeviceCont:

; 329  : 			break;
; 330  : 	}	
; 331  : 		
; 332  : 	Irp->IoStatus.Status = status;

	mov	eax, DWORD PTR _Irp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 333  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _Irp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 334  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN45@DeviceCont:

; 335  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN66@DeviceCont:
	DD	$LN33@DeviceCont
	DD	$LN25@DeviceCont
	DD	$LN1@DeviceCont
	DD	$LN19@DeviceCont
	DD	$LN29@DeviceCont
	DD	$LN21@DeviceCont
	DD	$LN1@DeviceCont
	DD	$LN9@DeviceCont
_DeviceControlDispatchRoutine@8 ENDP
PAGE	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\winddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@ DB 'c:\win'
	DB	'ddk\inc\ddk\wdm.h', 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	push	0
	push	23317					; 00005b15H
	push	OFFSET ??_C@_0BI@POHNOCHP@c?3?2winddk?2inc?2ddk?2wdm?4h?$AA@FNODOBFM@
	push	OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 23319: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
EXTRN	__imp__ZwClose@4:PROC
; Function compile flags: /Odtp
; File c:\radasm\wdk\projects\driver_projects\pdlr05_gladyr\filedevioctldemo\filedevioctldemo.c
;	COMDAT _DriverUnload@4
PAGE	SEGMENT
_DeviceObject$ = -8					; size = 4
_devExt$ = -4						; size = 4
_DriverObject$ = 8					; size = 4
_DriverUnload@4 PROC					; COMDAT

; 339  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 340  : 	PDEVICE_OBJECT		DeviceObject	= DriverObject->DeviceObject;

	mov	eax, DWORD PTR _DriverObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _DeviceObject$[ebp], ecx

; 341  : 	PDEVICE_EXTENSION	devExt		= DeviceObject->DeviceExtension;

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _devExt$[ebp], eax

; 342  : 	
; 343  : 	PAGED_CODE();

	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	ecx, al
	cmp	ecx, 1
	jle	SHORT $LN2@DriverUnlo
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	movzx	edx, al
	push	edx
	push	OFFSET ??_C@_0CF@FOPNHIJF@EX?3?5Pageable?5code?5called?5at?5IRQL@NNGAKEGL@
	call	_DbgPrint
	add	esp, 8
	push	0
	push	343					; 00000157H
	push	OFFSET ??_C@_0FJ@LFPODNJI@c?3?2radasm?2wdk?2projects?2driver_pr@NNGAKEGL@
	push	OFFSET ??_C@_01GBGANLPD@0?$AA@NNGAKEGL@
	call	DWORD PTR __imp__RtlAssert@16
$LN2@DriverUnlo:

; 344  : 	
; 345  : 	ZwClose(devExt->devFile);

	mov	eax, DWORD PTR _devExt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__ZwClose@4

; 346  : 	IoDeleteSymbolicLink((PUNICODE_STRING)&symbolicLinkName);

	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__IoDeleteSymbolicLink@4

; 347  : 	if (DeviceObject != NULL)

	cmp	DWORD PTR _DeviceObject$[ebp], 0
	je	SHORT $LN3@DriverUnlo

; 348  : 	{
; 349  : 		IoDeleteDevice(DeviceObject);

	mov	edx, DWORD PTR _DeviceObject$[ebp]
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN3@DriverUnlo:

; 350  : 	}
; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DriverUnload@4 ENDP
PAGE	ENDS
END
