; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	c:\radasm\wdk\projects\driver_projects\pdlr06_gladyr\pcidevenumerator\pcidevenumerator.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_serviceName
PUBLIC	_symbolicLinkName
PUBLIC	_imageName
_DATA	SEGMENT
_serviceName DB	'pciconfigviewer', 00H
_symbolicLinkName DB '\\.\pciconfigviewer', 00H
_imageName DB	'pciconfigviewer.sys', 00H
_DATA	ENDS
PUBLIC	??_C@_0BK@LPJGLJEC@Registry?50x?$CF02X?5?3?50x?$CF08X?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@ILIELPML@?6Bus?5?$DN?5?$CFd?0?5Device?5?$DN?5?$CFd?0?5Function@ ; `string'
PUBLIC	_EnumeratePCIDevice@4
EXTRN	__imp__printf:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BK@LPJGLJEC@Registry?50x?$CF02X?5?3?50x?$CF08X?6?$AA@
; File c:\radasm\wdk\projects\driver_projects\pdlr06_gladyr\pcidevenumerator\pcidevenumerator.c
CONST	SEGMENT
??_C@_0BK@LPJGLJEC@Registry?50x?$CF02X?5?3?50x?$CF08X?6?$AA@ DB 'Registry'
	DB	' 0x%02X : 0x%08X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ILIELPML@?6Bus?5?$DN?5?$CFd?0?5Device?5?$DN?5?$CFd?0?5Function@
CONST	SEGMENT
??_C@_0CH@ILIELPML@?6Bus?5?$DN?5?$CFd?0?5Device?5?$DN?5?$CFd?0?5Function@ DB 0aH
	DB	'Bus = %d, Device = %d, Function = %d', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _EnumeratePCIDevice@4
_TEXT	SEGMENT
_regNum$ = -92						; size = 4
_counterBytes$ = -88					; size = 4
_slotNum$ = -84						; size = 4
_outputBuffer$ = -80					; size = 64
_bus$ = -12						; size = 4
_device$ = -8						; size = 4
_function$ = -4						; size = 4
_enumerator$ = 8					; size = 4
_EnumeratePCIDevice@4 PROC				; COMDAT

; 4    : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 5    : 	PCI_SLOT_NUMBER_EXT	slotNum = {0};

	mov	DWORD PTR _slotNum$[ebp], 0

; 6    : 	ULONG					outputBuffer[16] = {0};

	mov	DWORD PTR _outputBuffer$[ebp], 0
	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _outputBuffer$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 7    : 	DWORD					counterBytes = 0;

	mov	DWORD PTR _counterBytes$[ebp], 0

; 8    : 	ULONG					bus = 0, device = 0, function = 0;

	mov	DWORD PTR _bus$[ebp], 0
	mov	DWORD PTR _device$[ebp], 0
	mov	DWORD PTR _function$[ebp], 0

; 9    : 	ULONG					regNum = 0;

	mov	DWORD PTR _regNum$[ebp], 0

; 10   : 		
; 11   : 	slotNum.u.bits.TestBit = 1;

	mov	ecx, DWORD PTR _slotNum$[ebp]
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR _slotNum$[ebp], ecx

; 12   : 	
; 13   : 	for(bus = 0 ; bus < PCI_MAX_BRIDGE_NUMBER ; bus++)

	mov	DWORD PTR _bus$[ebp], 0
	jmp	SHORT $LN13@EnumerateP
$LN12@EnumerateP:
	mov	edx, DWORD PTR _bus$[ebp]
	add	edx, 1
	mov	DWORD PTR _bus$[ebp], edx
$LN13@EnumerateP:
	cmp	DWORD PTR _bus$[ebp], 255		; 000000ffH
	jae	$LN14@EnumerateP

; 14   : 	{
; 15   : 		slotNum.u.bits.BusNumber = bus;

	mov	eax, DWORD PTR _bus$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _slotNum$[ebp]
	and	ecx, -16711681				; ff00ffffH
	or	ecx, eax
	mov	DWORD PTR _slotNum$[ebp], ecx

; 16   : 		for(device = 0 ; device < PCI_MAX_DEVICES ; device++)

	mov	DWORD PTR _device$[ebp], 0
	jmp	SHORT $LN10@EnumerateP
$LN9@EnumerateP:
	mov	edx, DWORD PTR _device$[ebp]
	add	edx, 1
	mov	DWORD PTR _device$[ebp], edx
$LN10@EnumerateP:
	cmp	DWORD PTR _device$[ebp], 32		; 00000020H
	jae	$LN8@EnumerateP

; 17   : 		{
; 18   : 			slotNum.u.bits.DeviceNumber = device;			

	mov	eax, DWORD PTR _device$[ebp]
	and	eax, 31					; 0000001fH
	shl	eax, 11					; 0000000bH
	mov	ecx, DWORD PTR _slotNum$[ebp]
	and	ecx, -63489				; ffff07ffH
	or	ecx, eax
	mov	DWORD PTR _slotNum$[ebp], ecx

; 19   : 			for(function = 0 ; function < PCI_MAX_FUNCTION ; function++)

	mov	DWORD PTR _function$[ebp], 0
	jmp	SHORT $LN7@EnumerateP
$LN6@EnumerateP:
	mov	edx, DWORD PTR _function$[ebp]
	add	edx, 1
	mov	DWORD PTR _function$[ebp], edx
$LN7@EnumerateP:
	cmp	DWORD PTR _function$[ebp], 8
	jae	$LN5@EnumerateP

; 20   : 			{
; 21   : 				slotNum.u.bits.FunctionNumber = function;

	mov	eax, DWORD PTR _function$[ebp]
	and	eax, 7
	shl	eax, 8
	mov	ecx, DWORD PTR _slotNum$[ebp]
	and	ecx, -1793				; fffff8ffH
	or	ecx, eax
	mov	DWORD PTR _slotNum$[ebp], ecx

; 22   : 				if(DeviceIoControl(	enumerator,
; 23   : 									IOCTL_GET_PCI_COMMON_HEADER,
; 24   : 									&slotNum,
; 25   : 									sizeof(slotNum),
; 26   : 									&outputBuffer, 
; 27   : 									sizeof(outputBuffer),
; 28   : 									&counterBytes, NULL)	)

	push	0
	lea	edx, DWORD PTR _counterBytes$[ebp]
	push	edx
	push	64					; 00000040H
	lea	eax, DWORD PTR _outputBuffer$[ebp]
	push	eax
	push	4
	lea	ecx, DWORD PTR _slotNum$[ebp]
	push	ecx
	push	2236416					; 00222000H
	mov	edx, DWORD PTR _enumerator$[ebp]
	push	edx
	call	DWORD PTR __imp__DeviceIoControl@32
	test	eax, eax
	je	SHORT $LN4@EnumerateP

; 29   : 				
; 30   : 				{
; 31   : 					_tprintf(_TEXT("\nBus = %d, Device = %d, Function = %d\n"), bus, device, function);

	mov	eax, DWORD PTR _function$[ebp]
	push	eax
	mov	ecx, DWORD PTR _device$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bus$[ebp]
	push	edx
	push	OFFSET ??_C@_0CH@ILIELPML@?6Bus?5?$DN?5?$CFd?0?5Device?5?$DN?5?$CFd?0?5Function@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H

; 32   : 					for(regNum = 0; regNum <= 15 ; regNum++)

	mov	DWORD PTR _regNum$[ebp], 0
	jmp	SHORT $LN3@EnumerateP
$LN2@EnumerateP:
	mov	eax, DWORD PTR _regNum$[ebp]
	add	eax, 1
	mov	DWORD PTR _regNum$[ebp], eax
$LN3@EnumerateP:
	cmp	DWORD PTR _regNum$[ebp], 15		; 0000000fH
	ja	SHORT $LN4@EnumerateP

; 33   : 					{
; 34   : 						_tprintf(_TEXT("Registry 0x%02X : 0x%08X\n"), regNum*4, outputBuffer[regNum]);	

	mov	ecx, DWORD PTR _regNum$[ebp]
	mov	edx, DWORD PTR _outputBuffer$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _regNum$[ebp]
	shl	eax, 2
	push	eax
	push	OFFSET ??_C@_0BK@LPJGLJEC@Registry?50x?$CF02X?5?3?50x?$CF08X?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH

; 35   : 					}

	jmp	SHORT $LN2@EnumerateP
$LN4@EnumerateP:

; 36   : 				}
; 37   : 			}

	jmp	$LN6@EnumerateP
$LN5@EnumerateP:

; 38   : 		}

	jmp	$LN9@EnumerateP
$LN8@EnumerateP:

; 39   : 	}	

	jmp	$LN12@EnumerateP
$LN14@EnumerateP:

; 40   : 	return;
; 41   : }

	mov	esp, ebp
	pop	ebp
	ret	4
_EnumeratePCIDevice@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@LOGFMMIL@?6Unsuccessful?5call?5of?5DeviceIoCo@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0BP@CPIIJOIG@Enter?5a?5number?5of?5the?5device?3?5?$AA@ ; `string'
PUBLIC	??_C@_0CH@PEJEJKE@Enter?5the?5device?5id?5as?5a?5hex?5val@ ; `string'
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_0CH@NCBNIHMF@Enter?5the?5vendor?5id?5as?5a?5hex?5val@ ; `string'
PUBLIC	_FindPCIDevice@4
EXTRN	__imp__getchar:PROC
EXTRN	__imp__scanf:PROC
;	COMDAT ??_C@_0CJ@LOGFMMIL@?6Unsuccessful?5call?5of?5DeviceIoCo@
CONST	SEGMENT
??_C@_0CJ@LOGFMMIL@?6Unsuccessful?5call?5of?5DeviceIoCo@ DB 0aH, 'Unsucce'
	DB	'ssful call of DeviceIoControl()', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CPIIJOIG@Enter?5a?5number?5of?5the?5device?3?5?$AA@
CONST	SEGMENT
??_C@_0BP@CPIIJOIG@Enter?5a?5number?5of?5the?5device?3?5?$AA@ DB 'Enter a'
	DB	' number of the device: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PEJEJKE@Enter?5the?5device?5id?5as?5a?5hex?5val@
CONST	SEGMENT
??_C@_0CH@PEJEJKE@Enter?5the?5device?5id?5as?5a?5hex?5val@ DB 'Enter the '
	DB	'device id as a hex value: 0x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NCBNIHMF@Enter?5the?5vendor?5id?5as?5a?5hex?5val@
CONST	SEGMENT
??_C@_0CH@NCBNIHMF@Enter?5the?5vendor?5id?5as?5a?5hex?5val@ DB 'Enter the'
	DB	' vendor id as a hex value: 0x', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _FindPCIDevice@4
_TEXT	SEGMENT
_deviceID$ = -112					; size = 2
_c$ = -108						; size = 4
_regNum$ = -104						; size = 4
_vendorID$ = -100					; size = 2
_counterBytes$ = -96					; size = 4
_slotNum$ = -92						; size = 4
_outputBuffer$ = -88					; size = 68
_deviceNumber$ = -12					; size = 2
_inputBuffer$ = -8					; size = 8
_enumerator$ = 8					; size = 4
_FindPCIDevice@4 PROC					; COMDAT

; 44   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H

; 45   : 	PCI_SLOT_NUMBER_EXT	slotNum = {0};

	mov	DWORD PTR _slotNum$[ebp], 0

; 46   : 	ULONG					outputBuffer[17] = {0};

	mov	DWORD PTR _outputBuffer$[ebp], 0
	push	64					; 00000040H
	push	0
	lea	eax, DWORD PTR _outputBuffer$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 47   : 	ULONG					regNum = 0;

	mov	DWORD PTR _regNum$[ebp], 0

; 48   : 	DWORD					counterBytes = 0;

	mov	DWORD PTR _counterBytes$[ebp], 0

; 49   : 	ULONG					inputBuffer[2] = {0};

	mov	DWORD PTR _inputBuffer$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _inputBuffer$[ebp+4], ecx

; 50   : 	WORD					vendorID = 0, deviceID = 0, deviceNumber = 0;

	xor	edx, edx
	mov	WORD PTR _vendorID$[ebp], dx
	xor	eax, eax
	mov	WORD PTR _deviceID$[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _deviceNumber$[ebp], cx

; 51   : 	int c;
; 52   : 	
; 53   : 	
; 54   : 	_tprintf(_TEXT("Enter the vendor id as a hex value: 0x"));

	push	OFFSET ??_C@_0CH@NCBNIHMF@Enter?5the?5vendor?5id?5as?5a?5hex?5val@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 55   : 	_tscanf("%x", &vendorID);

	lea	edx, DWORD PTR _vendorID$[ebp]
	push	edx
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	call	DWORD PTR __imp__scanf
	add	esp, 8
$LN11@FindPCIDev:

; 56   : 	while ((c = getchar()) != '\n' && c != EOF) { }

	call	DWORD PTR __imp__getchar
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN10@FindPCIDev
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN10@FindPCIDev
	jmp	SHORT $LN11@FindPCIDev
$LN10@FindPCIDev:

; 57   : 	_tprintf(_TEXT("Enter the device id as a hex value: 0x"));

	push	OFFSET ??_C@_0CH@PEJEJKE@Enter?5the?5device?5id?5as?5a?5hex?5val@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 58   : 	_tscanf("%x", &deviceID);

	lea	eax, DWORD PTR _deviceID$[ebp]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	call	DWORD PTR __imp__scanf
	add	esp, 8
$LN9@FindPCIDev:

; 59   : 	while ((c = getchar()) != '\n' && c != EOF) { }

	call	DWORD PTR __imp__getchar
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN8@FindPCIDev
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN8@FindPCIDev
	jmp	SHORT $LN9@FindPCIDev
$LN8@FindPCIDev:

; 60   : 	_tprintf(_TEXT("Enter a number of the device: "));

	push	OFFSET ??_C@_0BP@CPIIJOIG@Enter?5a?5number?5of?5the?5device?3?5?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 61   : 	_tscanf("%d", &deviceNumber);

	lea	ecx, DWORD PTR _deviceNumber$[ebp]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	call	DWORD PTR __imp__scanf
	add	esp, 8
$LN7@FindPCIDev:

; 62   : 	while ((c = getchar()) != '\n' && c != EOF) { }

	call	DWORD PTR __imp__getchar
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN6@FindPCIDev
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN6@FindPCIDev
	jmp	SHORT $LN7@FindPCIDev
$LN6@FindPCIDev:

; 63   : 	
; 64   : 	inputBuffer[0] = deviceID;

	movzx	edx, WORD PTR _deviceID$[ebp]
	mov	DWORD PTR _inputBuffer$[ebp], edx

; 65   : 	inputBuffer[0] = inputBuffer[0] << 16;

	mov	eax, DWORD PTR _inputBuffer$[ebp]
	shl	eax, 16					; 00000010H
	mov	DWORD PTR _inputBuffer$[ebp], eax

; 66   : 	inputBuffer[0] |= vendorID;

	movzx	ecx, WORD PTR _vendorID$[ebp]
	or	ecx, DWORD PTR _inputBuffer$[ebp]
	mov	DWORD PTR _inputBuffer$[ebp], ecx

; 67   : 	inputBuffer[1] = deviceNumber;

	movzx	edx, WORD PTR _deviceNumber$[ebp]
	mov	DWORD PTR _inputBuffer$[ebp+4], edx

; 68   : 	
; 69   : 	if(DeviceIoControl(	enumerator,
; 70   : 						IOCTL_FIND_PCI_DEVICE,
; 71   : 						&inputBuffer,
; 72   : 						sizeof(inputBuffer),
; 73   : 						&outputBuffer, 
; 74   : 						sizeof(outputBuffer),
; 75   : 						&counterBytes, NULL)	)

	push	0
	lea	eax, DWORD PTR _counterBytes$[ebp]
	push	eax
	push	68					; 00000044H
	lea	ecx, DWORD PTR _outputBuffer$[ebp]
	push	ecx
	push	8
	lea	edx, DWORD PTR _inputBuffer$[ebp]
	push	edx
	push	2236420					; 00222004H
	mov	eax, DWORD PTR _enumerator$[ebp]
	push	eax
	call	DWORD PTR __imp__DeviceIoControl@32
	test	eax, eax
	je	SHORT $LN5@FindPCIDev

; 76   : 				
; 77   : 	{
; 78   : 		slotNum.u.AsULONG = outputBuffer[16];

	mov	ecx, DWORD PTR _outputBuffer$[ebp+64]
	mov	DWORD PTR _slotNum$[ebp], ecx

; 79   : 		_tprintf(_TEXT("\nBus = %d, Device = %d, Function = %d\n"),
; 80   : 				 slotNum.u.bits.BusNumber, slotNum.u.bits.DeviceNumber, slotNum.u.bits.FunctionNumber);

	mov	edx, DWORD PTR _slotNum$[ebp]
	shr	edx, 8
	and	edx, 7
	push	edx
	mov	eax, DWORD PTR _slotNum$[ebp]
	shr	eax, 11					; 0000000bH
	and	eax, 31					; 0000001fH
	push	eax
	mov	ecx, DWORD PTR _slotNum$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	push	ecx
	push	OFFSET ??_C@_0CH@ILIELPML@?6Bus?5?$DN?5?$CFd?0?5Device?5?$DN?5?$CFd?0?5Function@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H

; 81   : 		for(regNum = 0; regNum <= 15 ; regNum++)

	mov	DWORD PTR _regNum$[ebp], 0
	jmp	SHORT $LN4@FindPCIDev
$LN3@FindPCIDev:
	mov	edx, DWORD PTR _regNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _regNum$[ebp], edx
$LN4@FindPCIDev:
	cmp	DWORD PTR _regNum$[ebp], 15		; 0000000fH
	ja	SHORT $LN2@FindPCIDev

; 82   : 		{
; 83   : 			_tprintf(_TEXT("Registry 0x%02X : 0x%08X\n"), regNum*4, outputBuffer[regNum]);	

	mov	eax, DWORD PTR _regNum$[ebp]
	mov	ecx, DWORD PTR _outputBuffer$[ebp+eax*4]
	push	ecx
	mov	edx, DWORD PTR _regNum$[ebp]
	shl	edx, 2
	push	edx
	push	OFFSET ??_C@_0BK@LPJGLJEC@Registry?50x?$CF02X?5?3?50x?$CF08X?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH

; 84   : 		}

	jmp	SHORT $LN3@FindPCIDev
$LN2@FindPCIDev:

; 85   : 	}
; 86   : 	else

	jmp	SHORT $LN12@FindPCIDev
$LN5@FindPCIDev:

; 87   : 		_tprintf(_TEXT("\nUnsuccessful call of DeviceIoControl()\n"));

	push	OFFSET ??_C@_0CJ@LOGFMMIL@?6Unsuccessful?5call?5of?5DeviceIoCo@
	call	DWORD PTR __imp__printf
	add	esp, 4
$LN12@FindPCIDev:

; 88   : 	return;
; 89   : }

	mov	esp, ebp
	pop	ebp
	ret	4
_FindPCIDevice@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@FAOLHICG@Enter?5a?5class?5code?5as?5a?5hex?5valu@ ; `string'
PUBLIC	_FindPCIDeviceByClassCode@4
;	COMDAT ??_C@_0CG@FAOLHICG@Enter?5a?5class?5code?5as?5a?5hex?5valu@
CONST	SEGMENT
??_C@_0CG@FAOLHICG@Enter?5a?5class?5code?5as?5a?5hex?5valu@ DB 'Enter a c'
	DB	'lass code as a hex value: 0x', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _FindPCIDeviceByClassCode@4
_TEXT	SEGMENT
_classCode$ = -108					; size = 4
_c$ = -104						; size = 4
_regNum$ = -100						; size = 4
_counterBytes$ = -96					; size = 4
_slotNum$ = -92						; size = 4
_outputBuffer$ = -88					; size = 68
_deviceNumber$ = -12					; size = 4
_inputBuffer$ = -8					; size = 8
_enumerator$ = 8					; size = 4
_FindPCIDeviceByClassCode@4 PROC			; COMDAT

; 92   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 93   : 	PCI_SLOT_NUMBER_EXT	slotNum = {0};

	mov	DWORD PTR _slotNum$[ebp], 0

; 94   : 	ULONG					outputBuffer[17] = {0};

	mov	DWORD PTR _outputBuffer$[ebp], 0
	push	64					; 00000040H
	push	0
	lea	eax, DWORD PTR _outputBuffer$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 95   : 	ULONG					regNum = 0;

	mov	DWORD PTR _regNum$[ebp], 0

; 96   : 	DWORD					counterBytes = 0;

	mov	DWORD PTR _counterBytes$[ebp], 0

; 97   : 	ULONG					inputBuffer[2] = {0};

	mov	DWORD PTR _inputBuffer$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _inputBuffer$[ebp+4], ecx

; 98   : 	ULONG					classCode = 0, deviceNumber = 0;

	mov	DWORD PTR _classCode$[ebp], 0
	mov	DWORD PTR _deviceNumber$[ebp], 0

; 99   : 	int c;
; 100  : 	
; 101  : 	_tprintf(_TEXT("Enter a class code as a hex value: 0x"));

	push	OFFSET ??_C@_0CG@FAOLHICG@Enter?5a?5class?5code?5as?5a?5hex?5valu@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 102  : 	_tscanf("%x", &classCode);

	lea	edx, DWORD PTR _classCode$[ebp]
	push	edx
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	call	DWORD PTR __imp__scanf
	add	esp, 8
$LN9@FindPCIDev@2:

; 103  : 	while ((c = getchar()) != '\n' && c != EOF) { }

	call	DWORD PTR __imp__getchar
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN8@FindPCIDev@2
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN8@FindPCIDev@2
	jmp	SHORT $LN9@FindPCIDev@2
$LN8@FindPCIDev@2:

; 104  : 	_tprintf(_TEXT("Enter a number of the device: "));

	push	OFFSET ??_C@_0BP@CPIIJOIG@Enter?5a?5number?5of?5the?5device?3?5?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 105  : 	_tscanf("%d", &deviceNumber);

	lea	eax, DWORD PTR _deviceNumber$[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	call	DWORD PTR __imp__scanf
	add	esp, 8
$LN7@FindPCIDev@2:

; 106  : 	while ((c = getchar()) != '\n' && c != EOF) { }

	call	DWORD PTR __imp__getchar
	mov	DWORD PTR _c$[ebp], eax
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN6@FindPCIDev@2
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN6@FindPCIDev@2
	jmp	SHORT $LN7@FindPCIDev@2
$LN6@FindPCIDev@2:

; 107  : 	
; 108  : 	// reset the lowest 8 bits
; 109  : 	classCode = classCode & (ULONG)0xffffff00;

	mov	ecx, DWORD PTR _classCode$[ebp]
	and	ecx, -256				; ffffff00H
	mov	DWORD PTR _classCode$[ebp], ecx

; 110  : 	inputBuffer[0] = classCode;

	mov	edx, DWORD PTR _classCode$[ebp]
	mov	DWORD PTR _inputBuffer$[ebp], edx

; 111  : 	inputBuffer[1] = deviceNumber;

	mov	eax, DWORD PTR _deviceNumber$[ebp]
	mov	DWORD PTR _inputBuffer$[ebp+4], eax

; 112  : 	
; 113  : 	if(DeviceIoControl(	enumerator,
; 114  : 						IOCTL_GET_PCI_CLASS_CODE,
; 115  : 						&inputBuffer,
; 116  : 						sizeof(inputBuffer),
; 117  : 						&outputBuffer, 
; 118  : 						sizeof(outputBuffer),
; 119  : 						&counterBytes, NULL)	)

	push	0
	lea	ecx, DWORD PTR _counterBytes$[ebp]
	push	ecx
	push	68					; 00000044H
	lea	edx, DWORD PTR _outputBuffer$[ebp]
	push	edx
	push	8
	lea	eax, DWORD PTR _inputBuffer$[ebp]
	push	eax
	push	2236424					; 00222008H
	mov	ecx, DWORD PTR _enumerator$[ebp]
	push	ecx
	call	DWORD PTR __imp__DeviceIoControl@32
	test	eax, eax
	je	SHORT $LN5@FindPCIDev@2

; 120  : 				
; 121  : 	{
; 122  : 		slotNum.u.AsULONG = outputBuffer[16];

	mov	edx, DWORD PTR _outputBuffer$[ebp+64]
	mov	DWORD PTR _slotNum$[ebp], edx

; 123  : 		_tprintf(_TEXT("\nBus = %d, Device = %d, Function = %d\n"),
; 124  : 				 slotNum.u.bits.BusNumber, slotNum.u.bits.DeviceNumber, slotNum.u.bits.FunctionNumber);

	mov	eax, DWORD PTR _slotNum$[ebp]
	shr	eax, 8
	and	eax, 7
	push	eax
	mov	ecx, DWORD PTR _slotNum$[ebp]
	shr	ecx, 11					; 0000000bH
	and	ecx, 31					; 0000001fH
	push	ecx
	mov	edx, DWORD PTR _slotNum$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	push	edx
	push	OFFSET ??_C@_0CH@ILIELPML@?6Bus?5?$DN?5?$CFd?0?5Device?5?$DN?5?$CFd?0?5Function@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H

; 125  : 		for(regNum = 0; regNum <= 15 ; regNum++)

	mov	DWORD PTR _regNum$[ebp], 0
	jmp	SHORT $LN4@FindPCIDev@2
$LN3@FindPCIDev@2:
	mov	eax, DWORD PTR _regNum$[ebp]
	add	eax, 1
	mov	DWORD PTR _regNum$[ebp], eax
$LN4@FindPCIDev@2:
	cmp	DWORD PTR _regNum$[ebp], 15		; 0000000fH
	ja	SHORT $LN2@FindPCIDev@2

; 126  : 		{
; 127  : 			_tprintf(_TEXT("Registry 0x%02X : 0x%08X\n"), regNum*4, outputBuffer[regNum]);	

	mov	ecx, DWORD PTR _regNum$[ebp]
	mov	edx, DWORD PTR _outputBuffer$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _regNum$[ebp]
	shl	eax, 2
	push	eax
	push	OFFSET ??_C@_0BK@LPJGLJEC@Registry?50x?$CF02X?5?3?50x?$CF08X?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH

; 128  : 		}

	jmp	SHORT $LN3@FindPCIDev@2
$LN2@FindPCIDev@2:

; 129  : 	}
; 130  : 	else

	jmp	SHORT $LN10@FindPCIDev@2
$LN5@FindPCIDev@2:

; 131  : 		_tprintf(_TEXT("\nUnsuccessful call of DeviceIoControl()\n"));

	push	OFFSET ??_C@_0CJ@LOGFMMIL@?6Unsuccessful?5call?5of?5DeviceIoCo@
	call	DWORD PTR __imp__printf
	add	esp, 4
$LN10@FindPCIDev@2:

; 132  : 	return;
; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_FindPCIDeviceByClassCode@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@LGCNFJIL@?6Press?5?8Enter?8?5to?5exit?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@JEBFDAOH@?6Can?8t?5delete?5service?5?8?$CFs?8?4?5Erro@ ; `string'
PUBLIC	??_C@_0BG@HLANJPHO@?6Service?5?8?$CFs?8?5deleted?$AA@ ; `string'
PUBLIC	??_C@_0CL@DNLIHKOL@?6Can?8t?5stop?5service?5?8?$CFs?8?4?5ErrorC@ ; `string'
PUBLIC	??_C@_0BG@GNCMMNDN@?6Service?5?8?$CFs?8?5stopped?$AA@ ; `string'
PUBLIC	??_C@_0DD@EPDMKAHF@?6Search?5of?5PCI?5configuration?5spa@ ; `string'
PUBLIC	??_C@_0DO@EDBFGHDP@?6Search?5of?5PCI?5configuration?5spa@ ; `string'
PUBLIC	??_C@_0DB@HNPALFON@?6Can?8t?5open?5symbolik?5link?5?8?$CFs?8?4?5@ ; `string'
PUBLIC	??_C@_0CN@NIILNDPD@?6Can?8t?5start?5service?5?8?$CFs?8?4?5Error@ ; `string'
PUBLIC	??_C@_0BO@FMFCEEJB@?6Service?5?8?$CFs?8?5already?5running?$AA@ ; `string'
PUBLIC	??_C@_0BG@KCIEGIHK@?6Service?5?8?$CFs?8?5started?$AA@ ; `string'
PUBLIC	??_C@_0CN@LJAJMOLA@?6Can?8t?5create?5service?5?8?$CFs?8?4?5Erro@ ; `string'
PUBLIC	??_C@_0BG@BDOMDCP@?6Service?5?8?$CFs?8?5created?$AA@ ; `string'
PUBLIC	??_C@_0DO@DMADPKCI@?6Can?8t?5get?5full?5path?5for?5service@ ; `string'
PUBLIC	??_C@_0DJ@MAJKNFIF@?6Can?8t?5open?5service?5?8?$CFs?8?4?5ErrorC@ ; `string'
PUBLIC	??_C@_0BF@HJJJKPCP@?6Service?5?8?$CFs?8?5opened?$AA@ ; `string'
PUBLIC	??_C@_0DF@NHKGILHH@?6Can?8t?5open?5Service?5Control?5Mana@ ; `string'
PUBLIC	??_C@_0BO@OGPOAGEO@?O?p?n?c?p?$OA?l?$OA?5?s?o?p?$OA?b?k?$LD?m?m?$PP?5?d?p?$OA?i?b?e?p?n?l?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_main
EXTRN	__imp__CloseServiceHandle@4:PROC
EXTRN	__imp__DeleteService@4:PROC
EXTRN	__imp__ControlService@12:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__StartServiceA@12:PROC
EXTRN	__imp__CreateServiceA@52:PROC
EXTRN	__imp__GetFullPathNameA@16:PROC
EXTRN	__imp__OpenServiceA@12:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__OpenSCManagerA@12:PROC
EXTRN	__imp__SetConsoleTitleA@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BI@LGCNFJIL@?6Press?5?8Enter?8?5to?5exit?6?$AA@
CONST	SEGMENT
??_C@_0BI@LGCNFJIL@?6Press?5?8Enter?8?5to?5exit?6?$AA@ DB 0aH, 'Press ''E'
	DB	'nter'' to exit', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JEBFDAOH@?6Can?8t?5delete?5service?5?8?$CFs?8?4?5Erro@
CONST	SEGMENT
??_C@_0CN@JEBFDAOH@?6Can?8t?5delete?5service?5?8?$CFs?8?4?5Erro@ DB 0aH, 'C'
	DB	'an''t delete service ''%s''. ErrorCode=0x%0X.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HLANJPHO@?6Service?5?8?$CFs?8?5deleted?$AA@
CONST	SEGMENT
??_C@_0BG@HLANJPHO@?6Service?5?8?$CFs?8?5deleted?$AA@ DB 0aH, 'Service '''
	DB	'%s'' deleted', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DNLIHKOL@?6Can?8t?5stop?5service?5?8?$CFs?8?4?5ErrorC@
CONST	SEGMENT
??_C@_0CL@DNLIHKOL@?6Can?8t?5stop?5service?5?8?$CFs?8?4?5ErrorC@ DB 0aH, 'C'
	DB	'an''t stop service ''%s''. ErrorCode=0x%0X.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GNCMMNDN@?6Service?5?8?$CFs?8?5stopped?$AA@
CONST	SEGMENT
??_C@_0BG@GNCMMNDN@?6Service?5?8?$CFs?8?5stopped?$AA@ DB 0aH, 'Service '''
	DB	'%s'' stopped', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EPDMKAHF@?6Search?5of?5PCI?5configuration?5spa@
CONST	SEGMENT
??_C@_0DD@EPDMKAHF@?6Search?5of?5PCI?5configuration?5spa@ DB 0aH, 'Search'
	DB	' of PCI configuration space by class code.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@EDBFGHDP@?6Search?5of?5PCI?5configuration?5spa@
CONST	SEGMENT
??_C@_0DO@EDBFGHDP@?6Search?5of?5PCI?5configuration?5spa@ DB 0aH, 'Search'
	DB	' of PCI configuration space by DeviceID and VendorID.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HNPALFON@?6Can?8t?5open?5symbolik?5link?5?8?$CFs?8?4?5@
CONST	SEGMENT
??_C@_0DB@HNPALFON@?6Can?8t?5open?5symbolik?5link?5?8?$CFs?8?4?5@ DB 0aH, 'C'
	DB	'an''t open symbolik link ''%s''. ErrorCode=0x%0X.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NIILNDPD@?6Can?8t?5start?5service?5?8?$CFs?8?4?5Error@
CONST	SEGMENT
??_C@_0CN@NIILNDPD@?6Can?8t?5start?5service?5?8?$CFs?8?4?5Error@ DB 0aH, 'C'
	DB	'an''t start service ''%s''. ErrorCode=0x%08X.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FMFCEEJB@?6Service?5?8?$CFs?8?5already?5running?$AA@
CONST	SEGMENT
??_C@_0BO@FMFCEEJB@?6Service?5?8?$CFs?8?5already?5running?$AA@ DB 0aH, 'S'
	DB	'ervice ''%s'' already running', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KCIEGIHK@?6Service?5?8?$CFs?8?5started?$AA@
CONST	SEGMENT
??_C@_0BG@KCIEGIHK@?6Service?5?8?$CFs?8?5started?$AA@ DB 0aH, 'Service '''
	DB	'%s'' started', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LJAJMOLA@?6Can?8t?5create?5service?5?8?$CFs?8?4?5Erro@
CONST	SEGMENT
??_C@_0CN@LJAJMOLA@?6Can?8t?5create?5service?5?8?$CFs?8?4?5Erro@ DB 0aH, 'C'
	DB	'an''t create service ''%s''. ErrorCode=0x%0X.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDOMDCP@?6Service?5?8?$CFs?8?5created?$AA@
CONST	SEGMENT
??_C@_0BG@BDOMDCP@?6Service?5?8?$CFs?8?5created?$AA@ DB 0aH, 'Service ''%'
	DB	's'' created', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@DMADPKCI@?6Can?8t?5get?5full?5path?5for?5service@
CONST	SEGMENT
??_C@_0DO@DMADPKCI@?6Can?8t?5get?5full?5path?5for?5service@ DB 0aH, 'Can'''
	DB	't get full path for service image ''%s''. ErrorCode=0x%0X.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MAJKNFIF@?6Can?8t?5open?5service?5?8?$CFs?8?4?5ErrorC@
CONST	SEGMENT
??_C@_0DJ@MAJKNFIF@?6Can?8t?5open?5service?5?8?$CFs?8?4?5ErrorC@ DB 0aH, 'C'
	DB	'an''t open service ''%s''. ErrorCode=0x%0X.', 0aH, 'Try creat'
	DB	'e...', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HJJJKPCP@?6Service?5?8?$CFs?8?5opened?$AA@
CONST	SEGMENT
??_C@_0BF@HJJJKPCP@?6Service?5?8?$CFs?8?5opened?$AA@ DB 0aH, 'Service ''%'
	DB	's'' opened', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NHKGILHH@?6Can?8t?5open?5Service?5Control?5Mana@
CONST	SEGMENT
??_C@_0DF@NHKGILHH@?6Can?8t?5open?5Service?5Control?5Mana@ DB 0aH, 'Can'''
	DB	't open Service Control Manager. ErrorCode=0x%0X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OGPOAGEO@?O?p?n?c?p?$OA?l?$OA?5?s?o?p?$OA?b?k?$LD?m?m?$PP?5?d?p?$OA?i?b?e?p?n?l?$AA@
CONST	SEGMENT
??_C@_0BO@OGPOAGEO@?O?p?n?c?p?$OA?l?$OA?5?s?o?p?$OA?b?k?$LD?m?m?$PP?5?d?p?$OA?i?b?e?p?n?l?$AA@ DB 0cfH
	DB	0f0H, 0eeH, 0e3H, 0f0H, 0e0H, 0ecH, 0e0H, ' ', 0f3H, 0efH, 0f0H
	DB	0e0H, 0e2H, 0ebH, 0b3H, 0edH, 0edH, 0ffH, ' ', 0e4H, 0f0H, 0e0H
	DB	0e9H, 0e2H, 0e5H, 0f0H, 0eeH, 0ecH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_statusBefore$ = -580					; size = 4
_lastError$ = -576					; size = 4
_bytesReturned$ = -572					; size = 4
_serviceStatus$ = -568					; size = 28
_scm$ = -540						; size = 4
_service$ = -536					; size = 4
_device$ = -532						; size = 4
_fullImagePath$ = -528					; size = 520
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 136  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 137  : 	HANDLE			scm = NULL;

	mov	DWORD PTR _scm$[ebp], 0

; 138  : 	HANDLE			service = NULL;

	mov	DWORD PTR _service$[ebp], 0

; 139  : 	HANDLE			device = INVALID_HANDLE_VALUE;

	mov	DWORD PTR _device$[ebp], -1

; 140  : 	DWORD			lastError	= ERROR_SUCCESS;

	mov	DWORD PTR _lastError$[ebp], 0

; 141  : 	DWORD			statusBefore = SERVICE_NOT_INSTALLED;

	mov	DWORD PTR _statusBefore$[ebp], 0

; 142  : 	DWORD			bytesReturned = 0;

	mov	DWORD PTR _bytesReturned$[ebp], 0

; 143  : 	TCHAR			fullImagePath[2*MAX_PATH] = {0};

	mov	BYTE PTR _fullImagePath$[ebp], 0
	push	519					; 00000207H
	push	0
	lea	eax, DWORD PTR _fullImagePath$[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 144  : 	SERVICE_STATUS	serviceStatus = {0};

	mov	DWORD PTR _serviceStatus$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _serviceStatus$[ebp+4], ecx
	mov	DWORD PTR _serviceStatus$[ebp+8], ecx
	mov	DWORD PTR _serviceStatus$[ebp+12], ecx
	mov	DWORD PTR _serviceStatus$[ebp+16], ecx
	mov	DWORD PTR _serviceStatus$[ebp+20], ecx
	mov	DWORD PTR _serviceStatus$[ebp+24], ecx

; 145  : 	
; 146  : 	SetConsoleTitle(_TEXT("Програма управління драйвером"));

	push	OFFSET ??_C@_0BO@OGPOAGEO@?O?p?n?c?p?$OA?l?$OA?5?s?o?p?$OA?b?k?$LD?m?m?$PP?5?d?p?$OA?i?b?e?p?n?l?$AA@
	call	DWORD PTR __imp__SetConsoleTitleA@4

; 147  : 	scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	push	983103					; 000f003fH
	push	0
	push	0
	call	DWORD PTR __imp__OpenSCManagerA@12
	mov	DWORD PTR _scm$[ebp], eax

; 148  : 	if(!scm)

	cmp	DWORD PTR _scm$[ebp], 0
	jne	SHORT $LN23@main

; 149  : 	{
; 150  : 		lastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lastError$[ebp], eax

; 151  : 		_tprintf(_TEXT("\nCan't open Service Control Manager. ErrorCode=0x%0X"), lastError);

	mov	edx, DWORD PTR _lastError$[ebp]
	push	edx
	push	OFFSET ??_C@_0DF@NHKGILHH@?6Can?8t?5open?5Service?5Control?5Mana@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 152  : 		return lastError;

	mov	eax, DWORD PTR _lastError$[ebp]
	jmp	$LN24@main
$LN23@main:

; 153  : 	}
; 154  : 
; 155  : 	service = OpenService(scm, serviceName,	SERVICE_START + SERVICE_STOP);

	push	48					; 00000030H
	push	OFFSET _serviceName
	mov	eax, DWORD PTR _scm$[ebp]
	push	eax
	call	DWORD PTR __imp__OpenServiceA@12
	mov	DWORD PTR _service$[ebp], eax

; 156  : 	if(service)

	cmp	DWORD PTR _service$[ebp], 0
	je	SHORT $LN22@main

; 157  : 	{
; 158  : 		statusBefore |= SERVICE_OPENED;

	mov	ecx, DWORD PTR _statusBefore$[ebp]
	or	ecx, 8
	mov	DWORD PTR _statusBefore$[ebp], ecx

; 159  : 		_tprintf(_TEXT("\nService '%s' opened"), serviceName);

	push	OFFSET _serviceName
	push	OFFSET ??_C@_0BF@HJJJKPCP@?6Service?5?8?$CFs?8?5opened?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 160  : 	}
; 161  : 	else

	jmp	$LN21@main
$LN22@main:

; 162  : 	{
; 163  : 		_tprintf(_TEXT("\nCan't open service '%s'. ErrorCode=0x%0X.\nTry create..."), 
; 164  : 					serviceName, GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	push	OFFSET _serviceName
	push	OFFSET ??_C@_0DJ@MAJKNFIF@?6Can?8t?5open?5service?5?8?$CFs?8?4?5ErrorC@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH

; 165  : 		bytesReturned = GetFullPathName(
; 166  : 								imageName,
; 167  : 								sizeof (fullImagePath)/sizeof(TCHAR), 
; 168  : 								fullImagePath, NULL);

	push	0
	lea	edx, DWORD PTR _fullImagePath$[ebp]
	push	edx
	push	520					; 00000208H
	push	OFFSET _imageName
	call	DWORD PTR __imp__GetFullPathNameA@16
	mov	DWORD PTR _bytesReturned$[ebp], eax

; 169  : 		if(bytesReturned == 0 || bytesReturned > sizeof (fullImagePath)/sizeof(TCHAR))

	cmp	DWORD PTR _bytesReturned$[ebp], 0
	je	SHORT $LN19@main
	cmp	DWORD PTR _bytesReturned$[ebp], 520	; 00000208H
	jbe	SHORT $LN20@main
$LN19@main:

; 170  : 		{
; 171  : 			lastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lastError$[ebp], eax

; 172  : 			_tprintf(_TEXT("\nCan't get full path for service image '%s'. ErrorCode=0x%0X."), 
; 173  : 						imageName, lastError);

	mov	eax, DWORD PTR _lastError$[ebp]
	push	eax
	push	OFFSET _imageName
	push	OFFSET ??_C@_0DO@DMADPKCI@?6Can?8t?5get?5full?5path?5for?5service@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH

; 174  : 		}
; 175  : 		else

	jmp	$LN21@main
$LN20@main:

; 176  : 		{
; 177  : 			service = CreateService(
; 178  : 							scm,
; 179  : 							serviceName,
; 180  : 							serviceName,
; 181  : 							SERVICE_START + SERVICE_STOP + DELETE,
; 182  : 							SERVICE_KERNEL_DRIVER,
; 183  : 							SERVICE_DEMAND_START,
; 184  : 							SERVICE_ERROR_IGNORE,
; 185  : 							fullImagePath,
; 186  : 							NULL, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _fullImagePath$[ebp]
	push	ecx
	push	0
	push	3
	push	1
	push	65584					; 00010030H
	push	OFFSET _serviceName
	push	OFFSET _serviceName
	mov	edx, DWORD PTR _scm$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateServiceA@52
	mov	DWORD PTR _service$[ebp], eax

; 187  : 			if(service)

	cmp	DWORD PTR _service$[ebp], 0
	je	SHORT $LN17@main

; 188  : 			{
; 189  : 				statusBefore |= SERVICE_INSTALLED;

	mov	eax, DWORD PTR _statusBefore$[ebp]
	or	eax, 1
	mov	DWORD PTR _statusBefore$[ebp], eax

; 190  : 				_tprintf(_TEXT("\nService '%s' created"), serviceName);

	push	OFFSET _serviceName
	push	OFFSET ??_C@_0BG@BDOMDCP@?6Service?5?8?$CFs?8?5created?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 191  : 			}
; 192  : 			else

	jmp	SHORT $LN21@main
$LN17@main:

; 193  : 			{
; 194  : 				lastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lastError$[ebp], eax

; 195  : 				_tprintf(_TEXT("\nCan't create service '%s'. ErrorCode=0x%0X."),
; 196  : 						 serviceName, lastError);

	mov	ecx, DWORD PTR _lastError$[ebp]
	push	ecx
	push	OFFSET _serviceName
	push	OFFSET ??_C@_0CN@LJAJMOLA@?6Can?8t?5create?5service?5?8?$CFs?8?4?5Erro@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
$LN21@main:

; 197  : 			}
; 198  : 		}
; 199  : 	}
; 200  : 
; 201  : 	if(service)

	cmp	DWORD PTR _service$[ebp], 0
	je	$LN15@main

; 202  : 	{
; 203  : 		if( StartService(service, 0, NULL) )

	push	0
	push	0
	mov	edx, DWORD PTR _service$[ebp]
	push	edx
	call	DWORD PTR __imp__StartServiceA@12
	test	eax, eax
	je	SHORT $LN14@main

; 204  : 		{
; 205  : 			statusBefore |= SERVICE_STARTED;

	mov	eax, DWORD PTR _statusBefore$[ebp]
	or	eax, 2
	mov	DWORD PTR _statusBefore$[ebp], eax

; 206  : 			_tprintf(_TEXT("\nService '%s' started"), serviceName);

	push	OFFSET _serviceName
	push	OFFSET ??_C@_0BG@KCIEGIHK@?6Service?5?8?$CFs?8?5started?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 207  : 		}
; 208  : 		else

	jmp	SHORT $LN13@main
$LN14@main:

; 209  : 		{
; 210  : 			lastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lastError$[ebp], eax

; 211  : 			if(ERROR_SERVICE_ALREADY_RUNNING == lastError)

	cmp	DWORD PTR _lastError$[ebp], 1056	; 00000420H
	jne	SHORT $LN12@main

; 212  : 			{
; 213  : 				_tprintf(_TEXT("\nService '%s' already running"), serviceName);

	push	OFFSET _serviceName
	push	OFFSET ??_C@_0BO@FMFCEEJB@?6Service?5?8?$CFs?8?5already?5running?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 214  : 				statusBefore |= SERVICE_RUNNING;

	mov	ecx, DWORD PTR _statusBefore$[ebp]
	or	ecx, 4
	mov	DWORD PTR _statusBefore$[ebp], ecx

; 215  : 			}
; 216  : 			else

	jmp	SHORT $LN13@main
$LN12@main:

; 217  : 			{
; 218  : 				_tprintf(_TEXT("\nCan't start service '%s'. ErrorCode=0x%08X."),
; 219  : 							serviceName, lastError);

	mov	edx, DWORD PTR _lastError$[ebp]
	push	edx
	push	OFFSET _serviceName
	push	OFFSET ??_C@_0CN@NIILNDPD@?6Can?8t?5start?5service?5?8?$CFs?8?4?5Error@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
$LN13@main:

; 220  : 			}
; 221  : 		}
; 222  : 		
; 223  : 		if( (statusBefore & SERVICE_STARTED) || (statusBefore & SERVICE_RUNNING) )

	mov	eax, DWORD PTR _statusBefore$[ebp]
	and	eax, 2
	jne	SHORT $LN9@main
	mov	ecx, DWORD PTR _statusBefore$[ebp]
	and	ecx, 4
	je	$LN15@main
$LN9@main:

; 224  : 		{
; 225  : 			device = CreateFile(
; 226  : 						symbolicLinkName,
; 227  : 						GENERIC_READ + GENERIC_WRITE, 0, NULL,
; 228  : 						OPEN_EXISTING, 0, NULL);

	push	0
	push	0
	push	3
	push	0
	push	0
	push	-1073741824				; c0000000H
	push	OFFSET _symbolicLinkName
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _device$[ebp], eax

; 229  : 			
; 230  : 			if(INVALID_HANDLE_VALUE == device)

	cmp	DWORD PTR _device$[ebp], -1
	jne	SHORT $LN8@main

; 231  : 			{
; 232  : 				lastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lastError$[ebp], eax

; 233  : 				_tprintf(_TEXT("\nCan't open symbolik link '%s'. ErrorCode=0x%0X."),
; 234  : 							symbolicLinkName, lastError);

	mov	edx, DWORD PTR _lastError$[ebp]
	push	edx
	push	OFFSET _symbolicLinkName
	push	OFFSET ??_C@_0DB@HNPALFON@?6Can?8t?5open?5symbolik?5link?5?8?$CFs?8?4?5@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH

; 235  : 			}
; 236  : 			else

	jmp	SHORT $LN15@main
$LN8@main:

; 237  : 			{
; 238  : 				EnumeratePCIDevice(device);

	mov	eax, DWORD PTR _device$[ebp]
	push	eax
	call	_EnumeratePCIDevice@4

; 239  : 				_tprintf(_TEXT("\nSearch of PCI configuration space by DeviceID and VendorID.\n"));

	push	OFFSET ??_C@_0DO@EDBFGHDP@?6Search?5of?5PCI?5configuration?5spa@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 240  : 				FindPCIDevice(device);

	mov	ecx, DWORD PTR _device$[ebp]
	push	ecx
	call	_FindPCIDevice@4

; 241  : 				_tprintf(_TEXT("\nSearch of PCI configuration space by class code.\n"));

	push	OFFSET ??_C@_0DD@EPDMKAHF@?6Search?5of?5PCI?5configuration?5spa@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 242  : 				FindPCIDeviceByClassCode(device);

	mov	edx, DWORD PTR _device$[ebp]
	push	edx
	call	_FindPCIDeviceByClassCode@4

; 243  : 				CloseHandle(device);

	mov	eax, DWORD PTR _device$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN15@main:

; 244  : 			}
; 245  : 		}
; 246  : 	}
; 247  : 
; 248  : 	if(statusBefore & SERVICE_STARTED)

	mov	ecx, DWORD PTR _statusBefore$[ebp]
	and	ecx, 2
	je	SHORT $LN6@main

; 249  : 	{
; 250  : 		if(ControlService(service, SERVICE_CONTROL_STOP, &serviceStatus))

	lea	edx, DWORD PTR _serviceStatus$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _service$[ebp]
	push	eax
	call	DWORD PTR __imp__ControlService@12
	test	eax, eax
	je	SHORT $LN5@main

; 251  : 		{
; 252  : 			_tprintf(_TEXT("\nService '%s' stopped"), serviceName);

	push	OFFSET _serviceName
	push	OFFSET ??_C@_0BG@GNCMMNDN@?6Service?5?8?$CFs?8?5stopped?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 253  : 		}
; 254  : 		else

	jmp	SHORT $LN6@main
$LN5@main:

; 255  : 		{
; 256  : 			lastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lastError$[ebp], eax

; 257  : 			_tprintf(_TEXT("\nCan't stop service '%s'. ErrorCode=0x%0X."),
; 258  : 						 serviceName, lastError);

	mov	ecx, DWORD PTR _lastError$[ebp]
	push	ecx
	push	OFFSET _serviceName
	push	OFFSET ??_C@_0CL@DNLIHKOL@?6Can?8t?5stop?5service?5?8?$CFs?8?4?5ErrorC@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
$LN6@main:

; 259  : 		}
; 260  : 	}
; 261  : 	if( (statusBefore & SERVICE_INSTALLED) && (SERVICE_STOPPED == serviceStatus.dwCurrentState) )

	mov	edx, DWORD PTR _statusBefore$[ebp]
	and	edx, 1
	je	SHORT $LN3@main
	cmp	DWORD PTR _serviceStatus$[ebp+4], 1
	jne	SHORT $LN3@main

; 262  : 	{
; 263  : 		if( DeleteService(service) )

	mov	eax, DWORD PTR _service$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteService@4
	test	eax, eax
	je	SHORT $LN2@main

; 264  : 		{
; 265  : 			_tprintf(_TEXT("\nService '%s' deleted"), serviceName);

	push	OFFSET _serviceName
	push	OFFSET ??_C@_0BG@HLANJPHO@?6Service?5?8?$CFs?8?5deleted?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 266  : 		}
; 267  : 		else

	jmp	SHORT $LN3@main
$LN2@main:

; 268  : 		{
; 269  : 			lastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lastError$[ebp], eax

; 270  : 			_tprintf(_TEXT("\nCan't delete service '%s'. ErrorCode=0x%0X."),
; 271  : 						 serviceName, lastError);

	mov	ecx, DWORD PTR _lastError$[ebp]
	push	ecx
	push	OFFSET _serviceName
	push	OFFSET ??_C@_0CN@JEBFDAOH@?6Can?8t?5delete?5service?5?8?$CFs?8?4?5Erro@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
$LN3@main:

; 272  : 		}
; 273  : 	}
; 274  : 
; 275  : 	CloseServiceHandle(service);

	mov	edx, DWORD PTR _service$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseServiceHandle@4

; 276  : 	CloseServiceHandle(scm);

	mov	eax, DWORD PTR _scm$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseServiceHandle@4

; 277  : 	_tprintf(_TEXT("\nPress 'Enter' to exit\n"));

	push	OFFSET ??_C@_0BI@LGCNFJIL@?6Press?5?8Enter?8?5to?5exit?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 4

; 278  : 	_gettchar();

	call	DWORD PTR __imp__getchar

; 279  : 	return lastError;

	mov	eax, DWORD PTR _lastError$[ebp]
$LN24@main:

; 280  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END
